<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- PWA Settings -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Chords">
    <meta name="theme-color" content="#121214">
    <title>Chords</title>

    <!-- Manifest - Data URI Fullscreen Display -->
    <link rel="manifest" href='data:application/manifest+json,{"display":"fullscreen","name":"Chords","short_name":"Chords","start_url":".","background_color":"#121214","theme_color":"#121214","orientation":"landscape"}'>
    
    <link rel="icon" type="image/svg+xml" href="lyre-icon.svg">
    <link rel="apple-touch-icon" href="lyre-icon.svg">

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@100;200;300;400;500;600&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap');

        :root {
            /* MODERN THEME VARS */
            --neon-blue: #00c3ff;
            --neon-purple: #bd00ff;
            --neon-orange: #ff9800;
            --neon-red: #ff3d3d;
            --neon-green: #00ff9d;
            --bg-dark: #121214;
            --panel-bg: rgba(22, 22, 28, 0.95);
            --glass-border: rgba(255, 255, 255, 0.15);
            
            /* LCD THEME VARS */
            --lcd-bg: #9BC84A;      /* Updated retro green */
            --lcd-ink: #2b3026;     /* Dark green/black ink */
            --lcd-shadow: rgba(43, 48, 38, 0.15); /* Shadow from ink color */
        }

        body {
            font-family: 'Outfit', sans-serif;
            font-weight: 300;
            background-color: var(--bg-dark);
            color: #e0e0e0;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            background-image: radial-gradient(circle at 50% 50%, #1a1a2e 0%, #000000 100%);
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            transition: background 0.3s ease, color 0.3s ease;
        }

        /* --- LCD RETRO THEME OVERRIDES --- */
        body.theme-lcd {
            /* Background with Pixel Dots Effect */
            background-color: var(--lcd-bg);
            background-image: 
                radial-gradient(rgba(43, 48, 38, 0.12) 15%, transparent 15%),
                radial-gradient(rgba(43, 48, 38, 0.12) 15%, transparent 15%);
            background-position: 0 0, 2px 2px;
            background-size: 4px 4px;
            
            color: var(--lcd-ink);
            font-family: 'Courier Prime', 'Courier New', monospace;
            font-weight: 700;
        }

        body.theme-lcd .glass-panel {
            background: transparent; /* No background to show dots */
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            border: 2px solid var(--lcd-ink);
            border-radius: 4px;
            box-shadow: 4px 4px 0px var(--lcd-shadow);
        }

        body.theme-lcd header {
            border-bottom: none;
            background: rgba(155, 200, 74, 0.8); /* Slight opacity to make text readable over dots */
        }

        /* FORCE COLOR OVERRIDE for inline styles (Roman numerals & DST) */
        body.theme-lcd [style*="color"] {
            color: var(--lcd-ink) !important;
            text-shadow: none !important;
        }

        /* Remove Neon Glows specifically */
        body.theme-lcd .text-neon-blue,
        body.theme-lcd .text-neon-purple,
        body.theme-lcd .text-neon-orange,
        body.theme-lcd .text-neon-red,
        body.theme-lcd .text-neon-green,
        body.theme-lcd h1 {
            color: var(--lcd-ink) !important;
            text-shadow: none !important;
        }

        body.theme-lcd select {
            background-color: transparent;
            color: var(--lcd-ink);
            border: 2px solid var(--lcd-ink);
            border-radius: 2px;
            font-family: 'Courier Prime', monospace;
            font-weight: 700;
            text-transform: uppercase;
        }
        
        body.theme-lcd .ui-label {
            color: var(--lcd-ink);
            font-family: 'Courier Prime', monospace;
            font-weight: 700;
            opacity: 0.8;
        }

        /* LCD Buttons */
        body.theme-lcd button, 
        body.theme-lcd .chord-btn {
            background: rgba(155, 200, 74, 0.4); /* Subtle backing for buttons */
            border: 2px solid var(--lcd-ink) !important;
            border-radius: 3px;
            color: var(--lcd-ink) !important;
            box-shadow: none !important;
            font-family: 'Courier Prime', monospace;
            font-weight: 700 !important;
            text-transform: uppercase;
        }

        /* Remove colored row indicators in LCD mode */
        body.theme-lcd .row-major-triad,
        body.theme-lcd .row-major-7,
        body.theme-lcd .row-harm-triad,
        body.theme-lcd .row-harm-7 {
            border-bottom-width: 2px;
            border-bottom-style: solid;
            border-bottom-color: var(--lcd-ink); 
        }

        /* Active State - INVERT COLORS */
        body.theme-lcd .active,
        body.theme-lcd .hold-active,
        body.theme-lcd .play-active,
        body.theme-lcd .btn-hold-active,
        body.theme-lcd .btn-rec-active {
            background-color: var(--lcd-ink) !important;
            color: var(--lcd-bg) !important; /* Text becomes screen color */
            border-color: var(--lcd-ink) !important;
            text-shadow: none !important;
            animation: none !important;
        }
        
        /* Knobs in LCD Mode */
        body.theme-lcd .knob-circle {
            background: transparent;
            border: 2px solid var(--lcd-ink);
            box-shadow: none;
        }
        body.theme-lcd .knob-indicator {
            background: var(--lcd-ink) !important;
            box-shadow: none;
            width: 3px;
        }
        body.theme-lcd .knob-scale {
            color: var(--lcd-ink);
            font-weight: bold;
        }
        
        /* Force knobs to ink color */
        body.theme-lcd .knob-container { color: var(--lcd-ink) !important; }
        body.theme-lcd .knob-blue, 
        body.theme-lcd .knob-orange, 
        body.theme-lcd .knob-purple, 
        body.theme-lcd .knob-red {
            color: var(--lcd-ink) !important;
        }

        /* Power button in LCD */
        body.theme-lcd .power-btn {
            background: transparent;
            border-color: var(--lcd-ink);
            color: var(--lcd-ink);
        }
        body.theme-lcd .power-btn:active {
            background: var(--lcd-ink);
            color: var(--lcd-bg);
        }

        /* --- END LCD OVERRIDES --- */


        /* Portrait Warning */
        #orientation-overlay { display: none; }
        @media (orientation: portrait) {
            #orientation-overlay { display: flex !important; }
            header, main { display: none !important; }
        }

        /* Phone Rotate Animation */
        @keyframes rotate-phone {
            0%, 20%, 100% { transform: rotate(0deg); }
            50%, 80% { transform: rotate(-90deg); }
        }
        .animate-rotate-phone {
            animation: rotate-phone 2.5s infinite ease-in-out;
            transform-origin: center;
        }

        .glass-panel {
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }

        /* UI Label - Lighter Gray */
        .ui-label {
            font-family: 'Outfit', sans-serif;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-size: 10px;
            color: #9ca3af;
        }

        /* --- KNOB STYLES --- */
        .knob-container {
            width: 44px;
            height: 44px;
            position: relative;
            cursor: ns-resize;
        }
        .knob-circle {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: linear-gradient(145deg, #2a2a2a, #111);
            border: 1px solid #666;
            position: relative;
            box-shadow: 0 4px 8px rgba(0,0,0,0.6);
            transition: all 0.3s ease;
        }
        .knob-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 45%;
            background: currentColor;
            transform-origin: bottom center;
            transform: translate(-50%, -100%) rotate(-135deg);
            border-radius: 2px;
            box-shadow: 0 0 5px currentColor;
            pointer-events: none;
        }

        .knob-scale {
            width: 34px;
            display: flex;
            justify-content: space-between;
            font-size: 8px;
            line-height: 1;
            margin-top: 2px;
            color: #6b7280;
            font-family: 'Outfit', sans-serif;
        }
        
        /* Small Knob for Header */
        .knob-sm { width: 34px; height: 34px; }
        .knob-sm .knob-circle { border-width: 1px; }

        .knob-blue { color: var(--neon-blue); }
        .knob-orange { color: var(--neon-orange); }
        .knob-purple { color: var(--neon-purple); }
        .knob-red { color: var(--neon-red); }

        .knob-blue .knob-indicator { background: var(--neon-blue); }
        .knob-orange .knob-indicator { background: var(--neon-orange); }
        .knob-purple .knob-indicator { background: var(--neon-purple); }
        .knob-red .knob-indicator { background: var(--neon-red); }

        button, .chord-btn, .knob-container, select {
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* Chord Buttons */
        .chord-btn {
            transition: all 0.1s ease-out;
            position: relative;
            overflow: hidden;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 300;
            letter-spacing: 0.05em;
        }
        .chord-btn:active { transform: scale(0.98); }
        .chord-btn.active {
            background: #3a3a3a;
            border-color: #555;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
            color: #fff;
            font-weight: 400;
            text-shadow: none;
        }
        .chord-btn.hold-active {
            background: #2a3a2a; 
            border-color: var(--neon-green); 
            border-width: 1px;
        }

        /* Updated Colors per user request */
        .row-major-triad { border-bottom: 2px solid #005f7f; }
        .row-major-7 { border-bottom: 2px solid #ff9800; }
        .row-harm-triad { border-bottom: 2px solid #9c27b0; }
        .row-harm-7 { border-bottom: 2px solid var(--neon-red); }

        select, input {
            background-color: #1a1a1a;
            color: #eee;
            font-family: 'Outfit', sans-serif;
            font-weight: 300;
            letter-spacing: 0.05em;
        }
        
        .play-active { 
            background-color: rgba(0, 255, 157, 0.2) !important;
            border-color: var(--neon-green) !important;
            color: var(--neon-green) !important;
            box-shadow: 0 0 10px rgba(0, 255, 157, 0.3);
        }
        
        .btn-hold-active {
            background-color: var(--neon-green) !important;
            color: #000 !important;
            border-color: var(--neon-green) !important;
            font-weight: 600 !important;
            box-shadow: 0 0 15px rgba(0, 255, 157, 0.4);
        }

        .btn-rec-active { 
            background-color: var(--neon-red) !important; 
            color: white !important;
            border-color: var(--neon-red) !important;
            font-weight: 600 !important;
            box-shadow: 0 0 15px rgba(255, 61, 61, 0.4);
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.8; } 100% { opacity: 1; } }
        
        .custom-scrollbar::-webkit-scrollbar { width: 0px; }

        /* Power Button Style */
        .power-btn:active {
            transform: scale(0.95);
            background-color: rgba(255, 61, 61, 0.2);
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col overflow-hidden text-xs p-2 gap-2 font-light">

    <!-- Orientation Overlay -->
    <div id="orientation-overlay" class="fixed inset-0 z-[100] bg-black flex flex-col items-center justify-center text-center p-6">
        <div class="mb-6 animate-rotate-phone">
            <svg width="80" height="80" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="1.5">
                <rect x="5" y="2" width="14" height="20" rx="2" ry="2" />
                <path d="M12 18h.01" />
            </svg>
        </div>
        <h2 class="text-white text-xl font-light mb-2 tracking-wide font-outfit">Forgatás szükséges</h2>
        <p class="text-gray-400 font-light font-outfit">Az alkalmazás csak fekvő módban használható!</p>
    </div>

    <!-- Header -->
    <header class="glass-panel px-3 py-1 flex items-center justify-between shrink-0 h-16 z-20 transition-all">
        <!-- Left: Controls -->
        <div class="flex items-center gap-3">
            <div class="flex items-center gap-3">
                <!-- Theme Trigger: ID added for JS -->
                <h1 id="app-title" class="text-neon-blue font-medium text-xl tracking-[0.1em] font-outfit cursor-pointer select-none hover:opacity-80 transition-opacity" style="text-shadow: 0 0 15px rgba(0,195,255,0.3);">CHORDS</h1>
                
                <div class="flex flex-col items-center justify-center">
                    <select id="key-select" class="bg-gray-800/50 border border-gray-600 rounded px-1 py-0.5 outline-none text-xs text-center focus:border-neon-blue transition-colors w-16"></select>
                    <span class="ui-label text-[10px] mt-0.5">HANGNEM</span>
                </div>
            </div>
            
            <div class="flex flex-col items-center">
                <div class="knob-container knob-sm knob-blue" data-param="bpm" data-min="40" data-max="200" data-val="90">
                    <div class="knob-circle"><div class="knob-indicator"></div></div>
                </div>
                <div class="knob-scale"><span>40</span><span>200</span></div>
                <span class="ui-label text-[10px] mt-0 font-bold text-blue-400">BPM</span>
            </div>
        </div>

        <!-- Header Mixer -->
        <div class="flex flex-1 items-center justify-evenly border-l border-gray-700 pl-4 ml-2" style="border-color: inherit;">
            <!-- DRUM -->
            <div class="flex flex-col items-center">
                <div class="knob-container knob-sm knob-red" data-param="drumVol" data-min="0" data-max="100" data-val="50">
                    <div class="knob-circle"><div class="knob-indicator"></div></div>
                </div>
                <div class="knob-scale"><span>0</span><span>100</span></div>
                <span class="ui-label text-[10px] mt-0 font-bold text-red-400">DOB</span>
            </div>
            <!-- CHORD -->
            <div class="flex flex-col items-center">
                <div class="knob-container knob-sm knob-purple" data-param="chordVol" data-min="0" data-max="100" data-val="50">
                    <div class="knob-circle"><div class="knob-indicator"></div></div>
                </div>
                <div class="knob-scale"><span>0</span><span>100</span></div>
                <span class="ui-label text-[10px] mt-0 font-bold text-purple-400">AKK</span>
            </div>
            <!-- REVERB -->
            <div class="flex flex-col items-center">
                <div class="knob-container knob-sm knob-blue" data-param="fxReverb" data-min="0" data-max="100" data-val="0">
                    <div class="knob-circle"><div class="knob-indicator"></div></div>
                </div>
                <div class="knob-scale"><span>0</span><span>100</span></div>
                <span class="ui-label text-[10px] mt-0 font-bold text-blue-400">REV</span>
            </div>
            <!-- DISTORTION -->
            <div class="flex flex-col items-center">
                <div class="knob-container knob-sm knob-orange" data-param="fxDistortion" data-min="0" data-max="100" data-val="0">
                    <div class="knob-circle"><div class="knob-indicator"></div></div>
                </div>
                <div class="knob-scale"><span>0</span><span>100</span></div>
                <span class="ui-label text-[10px] mt-0 font-bold" style="color: var(--neon-orange);">DST</span>
            </div>
            <!-- TREMOLO -->
            <div class="flex flex-col items-center">
                <div class="knob-container knob-sm knob-purple" data-param="fxTremolo" data-min="0" data-max="100" data-val="0">
                    <div class="knob-circle"><div class="knob-indicator"></div></div>
                </div>
                <div class="knob-scale"><span>0</span><span>100</span></div>
                <span class="ui-label text-[10px] mt-0 font-bold text-purple-400">TRM</span>
            </div>
        </div>

        <!-- Exit Button (Right Side with Margin) -->
        <div class="ml-4">
            <button id="exit-btn" class="power-btn w-8 h-8 rounded-full border border-red-900/50 flex items-center justify-center text-red-500 bg-red-900/10 hover:bg-red-900/30 transition-all shadow-lg" aria-label="Kilépés">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path>
                    <line x1="12" y1="2" x2="12" y2="12"></line>
                </svg>
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 flex gap-2 overflow-hidden min-h-0">
        
        <!-- Left: Chord Matrix -->
        <div class="flex-grow glass-panel p-2 flex flex-col min-w-0 relative">
            <div id="chord-grid" class="grid grid-cols-7 grid-rows-4 gap-2 h-full w-full">
                <!-- JS Generated -->
            </div>
        </div>

        <!-- Center: Console (Distributed Vertically) -->
        <div class="w-52 shrink-0 glass-panel p-3 flex flex-col gap-2 overflow-hidden justify-between">
            
            <!-- 1. Chord Tone -->
            <div class="flex flex-col gap-0.5 border-b border-gray-700/50 pb-2" style="border-color: inherit;">
                <label class="ui-label text-neon-purple">Hangszinek</label>
                <select id="chord-tone-select" class="bg-gray-800/50 border border-gray-600 rounded px-2 py-1 outline-none text-xs text-white w-full">
                    <!-- Populated by JS -->
                </select>
            </div>

            <!-- 2. Rhythm Control -->
            <div class="flex flex-col gap-1.5 bg-gray-900/40 p-2 rounded border border-gray-700/50" style="border-color: inherit; background: transparent;">
                <div class="flex items-center justify-between">
                    <label class="ui-label text-[10px]">RITMUS</label>
                </div>
                <select id="rhythm-select" class="bg-gray-800 border border-gray-600 text-xs outline-none w-full p-1 rounded">
                    <!-- Populated by JS -->
                </select>
            </div>

            <!-- 3. Transport -->
            <div class="flex gap-2 h-14">
                <button id="drum-btn" class="flex-1 h-full bg-gray-800 rounded ui-label text-[10px] border border-gray-600 text-gray-300 transition-all shadow-md hover:bg-gray-700 tracking-wider">DOB</button>
                <button id="hold-btn" class="flex-1 h-full bg-gray-800 rounded ui-label text-[10px] border border-gray-600 text-gray-300 transition-all shadow-md hover:bg-gray-700 tracking-wider">HOLD</button>
                <button id="rec-btn" class="flex-1 h-full bg-gray-800 rounded ui-label text-[10px] border border-red-900/60 text-red-400 hover:bg-red-900/20 transition-all shadow-md tracking-wider">REC</button>
            </div>
        </div>

    </main>

<script>
/**
 * CHORDS v3.3 - JAVÍTOTT VERZIÓ
 */

/* --- DATA --- */
const NOTES = ["C", "C#", "D", "Eb", "E", "F", "F#", "G", "Ab", "A", "Bb", "H"];
const ROMAN_MAJ = ["I", "ii", "iii", "IV", "V", "vi", "vii°"];

const SCALES = {
    major: [0, 2, 4, 5, 7, 9, 11],
    harmonicMinor: [0, 2, 3, 5, 7, 8, 11]
};

const CHORD_PRESETS = {
    mellotron:   { name: 'Mellotron',    type: 'triangle', filter: 1700, attack: 0.08, detune: 4, sub: true,  release: 0.52 },
    epiano:      { name: 'E-Piano',      type: 'sine',     filter: 2600, attack: 0.02, detune: 2, fm: true,   fmIndex: 8,  release: 0.36 },
    wurlitzer:   { name: 'Wurlitzer',    type: 'square',   filter: 2200, attack: 0.03, detune: 5, fm: true,   fmIndex: 6,  release: 0.34 },
    fluteOrgan:  { name: 'Flute Organ',  type: 'triangle', filter: 3000, attack: 0.06, detune: 1, sub: true,  release: 0.58 },
    jazzOrgan:   { name: 'Jazz Organ',   type: 'square',   filter: 3200, attack: 0.02, detune: 1, sub: true,  release: 0.42 },
    analogPad:   { name: 'Analog Pad',   type: 'sawtooth', filter: 1300, attack: 0.16, detune: 8,             release: 0.7  },
    tapeChoir:   { name: 'Tape Choir',   type: 'triangle', filter: 1500, attack: 0.12, detune: 6,             release: 0.66 },
    softBrass:   { name: 'Soft Brass',   type: 'sawtooth', filter: 2100, attack: 0.06, detune: 4,             release: 0.44 },
    celestaPad:  { name: 'Celesta Pad',  type: 'sine',     filter: 3400, attack: 0.04, detune: 2, fm: true,   fmIndex: 4,  release: 0.48 },
    nylonKeys:   { name: 'Nylon Keys',   type: 'triangle', filter: 2400, attack: 0.03, detune: 3,             release: 0.4  },
    silkPad:     { name: 'Silk Pad',     type: 'sine',     filter: 1800, attack: 0.20, detune: 3, sub: true,  release: 0.8  },
    dreamPad:    { name: 'Dream Pad',    type: 'triangle', filter: 2000, attack: 0.25, detune: 5,             release: 0.9  },
    velvetKeys:  { name: 'Velvet Keys',  type: 'sine',     filter: 2800, attack: 0.05, detune: 1.5,           release: 0.5  }
};

const DRUM_PATTERNS = {
    'pop':       { name: 'Standard Pop', pat: [1,0,3,0, 2,0,3,0, 1,0,3,0, 2,0,3,0] },
    'disco':     { name: 'Disco', pat: [1,0,1,0, 2,0,1,0, 1,0,1,0, 2,0,1,0] },
    'blues':     { name: 'Blues Shuffle', pat: [1,0,0,2, 0,0,1,0, 0,2,0,1, 0,0,0,0] },
    'techno':    { name: 'Techno', pat: [1,0,2,0, 1,0,2,0, 1,0,2,0, 1,0,2,0] },
    'funk':      { name: 'Funk', pat: [1,0,3,1, 2,3,0,1, 0,3,0,2, 0,3,1,0] },
    'dnb':       { name: 'Drum & Bass', pat: [1,0,0,0, 2,0,1,0, 0,0,2,0, 0,1,0,0] },
    'trap':      { name: 'Trap', pat: [1,0,0,3, 0,3,2,0, 3,0,3,0, 2,0,3,3] },
    'waltz':     { name: 'Waltz 3/4', pat: [1,0,0,0, 2,3,0,0, 2,3,0,0, 0,0,0,0] },
    'jazzwaltz': { name: 'Jazz Waltz', pat: [1,0,0,3, 2,0,3,0, 2,3,0,3, 0,0,0,0] },
    'swing':     { name: 'Swing', pat: [1,0,3,2, 0,3,1,0, 3,2,0,3, 1,0,3,0] },
    'bossa':     { name: 'Bossa Nova', pat: [1,0,3,1, 2,0,3,0, 1,3,0,2, 0,3,0,0] },
    'samba':     { name: 'Samba', pat: [1,3,2,3, 1,3,2,3, 1,3,2,3, 1,3,2,3] },
    'reggae':    { name: 'Reggae', pat: [0,0,1,0, 2,3,0,0, 0,0,1,0, 2,3,0,0] },
    'house':     { name: 'House', pat: [1,3,2,3, 1,3,2,3, 1,3,2,3, 1,3,2,3] },
    'garage':    { name: 'UK Garage', pat: [1,0,0,3, 2,3,0,0, 1,3,0,0, 2,0,3,3] },
    'halftime':  { name: 'Halftime', pat: [1,0,0,0, 0,0,0,0, 2,0,0,0, 0,0,0,0] },
    'tresillo':  { name: 'Tresillo', pat: [1,0,0,2, 0,0,1,0, 0,2,0,0, 0,0,0,0] },
    'afrobeat':  { name: 'Afrobeat', pat: [1,3,0,3, 2,0,3,1, 0,3,2,0, 3,1,0,3] },
    'breakbeat': { name: 'Breakbeat', pat: [1,0,3,0, 2,3,1,3, 0,3,2,0, 3,0,1,3] },
    'moombah':   { name: 'Moombahton', pat: [1,0,0,0, 2,0,0,3, 1,0,3,0, 2,0,3,0] }
};

const CHORDS_MAP = {
    maj: [0, 4, 7],
    m: [0, 3, 7],
    dim: [0, 3, 6],
    aug: [0, 4, 8],
    '7': [0, 4, 7, 10],
    M7: [0, 4, 7, 11],
    m7: [0, 3, 7, 10],
    mM7: [0, 3, 7, 11],
    m7b5: [0, 3, 6, 10],
    dim7: [0, 3, 6, 9]
};

const CHORD_QUALITY_MAP = {
    'M': 'maj',
    'm': 'm',
    'dim': 'dim',
    'aug': 'aug',
    '7': '7',
    'M7': 'M7',
    'm7': 'm7',
    'mM7': 'mM7',
    'm7b5': 'm7b5',
    'dim7': 'dim7'
};

/* --- AUDIO ENGINE --- */
const AudioEngine = {
    ctx: null,
    master: null,
    limiter: null,
    bus: { chord: null, drum: null },
    filter: null,
    shaper: null,
    lfo: null,
    lfoGain: null,
    voices: [],
    voiceCount: 4,
    previousVoicing: null,
    noiseBuffers: {},
    fxNodes: {},

    params: {
        filterFreq: 2000,
        detune: 15,
        masterVol: 0.5,
        chordVol: 0.5,
        drumVol: 0.5,
        chordTone: 'mellotron'
    },

    fxState: {
        reverb: 0,
        distortion: 0,
        tremolo: 0
    },
    
    dest: null,
    recorder: null,
    chunks: []
};

AudioEngine.init = function() {
    const AC = window.AudioContext || window.webkitAudioContext;
    this.ctx = new AC({ latencyHint: 'interactive' });
    
    // --- MASTER CHAIN ---
    this.limiter = this.ctx.createDynamicsCompressor();
    this.limiter.threshold.value = -10;
    this.limiter.ratio.value = 12;
    this.limiter.attack.value = 0.003;
    
    this.master = this.ctx.createGain();
    this.master.gain.value = this.params.masterVol;
    
    // --- BUSES ---
    this.bus.chord = this.ctx.createGain();
    this.bus.chord.gain.value = this.params.chordVol;
    this.bus.drum = this.ctx.createGain();
    this.bus.drum.gain.value = this.params.drumVol;

    // --- GLOBAL FX ---
    this.filter = this.ctx.createBiquadFilter();
    this.filter.type = "lowpass";
    this.filter.Q.value = 0.7; 
    this.filter.frequency.value = this.params.filterFreq;
    
    this.shaper = this.ctx.createWaveShaper();
    this.updateCharacter(25); 

    this.lfo = this.ctx.createOscillator();
    this.lfo.frequency.value = 1.5; 
    this.lfoGain = this.ctx.createGain();
    this.lfoGain.gain.value = 0;
    this.lfo.connect(this.lfoGain);
    this.lfo.start();

    // --- CHORD FX CHAIN (chord only, drums bypass) ---
    this.setupChordEffects();

    // ROUTING
    this.bus.chord.connect(this.fxNodes.distortionInput);
    this.bus.drum.connect(this.master);

    this.filter.connect(this.shaper);
    this.shaper.connect(this.master);
    this.master.connect(this.limiter);
    this.limiter.connect(this.ctx.destination);
    
    this.dest = this.ctx.createMediaStreamDestination();
    this.limiter.connect(this.dest);

    this.noiseBuffers.snare = this.createNoiseBuffer(0.15, 0.8);
    this.noiseBuffers.hat = this.createNoiseBuffer(0.05, 0.5);
    this.createVoiceBank();
};

AudioEngine.resume = function() { 
    if (this.ctx && this.ctx.state === 'suspended') {
        // KRITIKUS: Mentsük el a jelenlegi hangerőket
        const savedDrumVol = this.params.drumVol;
        const savedChordVol = this.params.chordVol;
        
        this.ctx.resume().then(() => {
            // Resume után azonnal visszaállítjuk a hangerőket
            if(this.bus.drum) {
                this.bus.drum.gain.setValueAtTime(savedDrumVol, this.ctx.currentTime);
            }
            if(this.bus.chord) {
                this.bus.chord.gain.setValueAtTime(savedChordVol, this.ctx.currentTime);
            }
        });
    }
};

AudioEngine.setVol = function(type, val) {
    if(!this.ctx) return;
    const gain = val / 100;
    if(type === 'chord') {
        this.params.chordVol = gain;
        this.bus.chord.gain.setTargetAtTime(gain, this.ctx.currentTime, 0.05);
    }
    if(type === 'drum') {
        this.params.drumVol = gain;
        this.bus.drum.gain.setTargetAtTime(gain, this.ctx.currentTime, 0.05);
    }
};

AudioEngine.setupChordEffects = function() {
    const n = this.fxNodes;

    n.distortionInput = this.ctx.createGain();
    n.distortionDry = this.ctx.createGain();
    n.distortionWet = this.ctx.createGain();
    n.distortionSum = this.ctx.createGain();
    n.distortionDrive = this.ctx.createGain();
    n.distortion = this.ctx.createWaveShaper();
    n.distortion.oversample = '4x';

    n.tremoloGain = this.ctx.createGain();
    n.tremoloDepth = this.ctx.createGain();
    n.tremoloLfo = this.ctx.createOscillator();
    n.tremoloLfo.connect(n.tremoloDepth);
    n.tremoloDepth.connect(n.tremoloGain.gain);
    n.tremoloLfo.start();

    n.reverbConvolver = this.ctx.createConvolver();
    n.reverbConvolver.buffer = this.createReverbImpulse(2.8, 2.6);
    n.reverbDry = this.ctx.createGain();
    n.reverbWet = this.ctx.createGain();

    n.distortionInput.connect(n.distortionDry);
    n.distortionDry.connect(n.distortionSum);

    n.distortionInput.connect(n.distortionDrive);
    n.distortionDrive.connect(n.distortion);
    n.distortion.connect(n.distortionWet);
    n.distortionWet.connect(n.distortionSum);

    n.distortionSum.connect(n.tremoloGain);

    n.tremoloGain.connect(n.reverbDry);
    n.reverbDry.connect(this.filter);

    n.tremoloGain.connect(n.reverbConvolver);
    n.reverbConvolver.connect(n.reverbWet);
    n.reverbWet.connect(this.filter);

    this.updateDistortion();
    this.updateTremolo();
    this.updateReverb();
};

AudioEngine.setEffectAmount = function(name, amount) {
    if (typeof this.fxState[name] === 'undefined') return;
    this.fxState[name] = Math.max(0, Math.min(100, amount));
    this.updateEffect(name);
};

AudioEngine.updateEffect = function(name) {
    if (!this.ctx) return;
    if (name === 'distortion') this.updateDistortion();
    if (name === 'tremolo') this.updateTremolo();
    if (name === 'reverb') this.updateReverb();
};

AudioEngine.updateDistortion = function() {
    const n = this.fxNodes;
    if (!n.distortion || !n.distortionDrive) return;
    const amount = this.fxState.distortion;
    const drive = 1 + (amount / 100) * 4.5;
    const wet = (amount / 100) * 0.85;
    n.distortionDrive.gain.setTargetAtTime(drive, this.ctx.currentTime, 0.05);
    n.distortion.curve = amount > 0 ? this.createSoftClipCurve(amount) : this.createIdentityCurve();
    n.distortionWet.gain.setTargetAtTime(wet, this.ctx.currentTime, 0.05);
    n.distortionDry.gain.setTargetAtTime(1 - (wet * 0.65), this.ctx.currentTime, 0.05);
};

AudioEngine.updateTremolo = function() {
    const n = this.fxNodes;
    if (!n.tremoloGain) return;
    const amount = this.fxState.tremolo;
    const depth = (amount / 100) * 0.7;
    n.tremoloGain.gain.setTargetAtTime(1 - (depth * 0.5), this.ctx.currentTime, 0.05);
    n.tremoloDepth.gain.setTargetAtTime(depth, this.ctx.currentTime, 0.05);
    n.tremoloLfo.frequency.setTargetAtTime(2 + (amount * 0.06), this.ctx.currentTime, 0.1);
};

AudioEngine.updateReverb = function() {
    const n = this.fxNodes;
    if (!n.reverbDry) return;
    const wet = (this.fxState.reverb / 100) * 0.8;
    n.reverbWet.gain.setTargetAtTime(wet, this.ctx.currentTime, 0.06);
    n.reverbDry.gain.setTargetAtTime(1 - (wet * 0.45), this.ctx.currentTime, 0.06);
};

AudioEngine.createSoftClipCurve = function(amount) {
    const samples = 2048;
    const curve = new Float32Array(samples);
    const k = 1 + (amount / 100) * 8;
    for (let i = 0; i < samples; i++) {
        const x = ((i * 2) / samples) - 1;
        curve[i] = Math.tanh(k * x) / Math.tanh(k);
    }
    return curve;
};

AudioEngine.createIdentityCurve = function() {
    const samples = 512;
    const curve = new Float32Array(samples);
    for (let i = 0; i < samples; i++) curve[i] = ((i * 2) / (samples - 1)) - 1;
    return curve;
};

AudioEngine.createReverbImpulse = function(seconds, decay) {
    const length = Math.floor(this.ctx.sampleRate * seconds);
    const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
        const data = impulse.getChannelData(ch);
        for (let i = 0; i < length; i++) {
            const t = i / length;
            const env = Math.pow(1 - t, decay);
            data[i] = ((Math.random() * 2) - 1) * env;
        }
    }
    return impulse;
};

AudioEngine.createVoiceBank = function() {
    const panPositions = [-0.18, -0.06, 0.06, 0.18];
    for (let i = 0; i < this.voiceCount; i++) {
        const osc = this.ctx.createOscillator();
        const subOsc = this.ctx.createOscillator();
        const filter = this.ctx.createBiquadFilter();
        const gain = this.ctx.createGain();
        const subGain = this.ctx.createGain();
        const panner = this.ctx.createStereoPanner();

        osc.type = 'triangle';
        subOsc.type = 'sine';
        filter.type = 'lowpass';
        filter.frequency.value = 1800;
        filter.Q.value = 0.7;
        gain.gain.value = 0.0001;
        subGain.gain.value = 0.0;
        panner.pan.value = panPositions[i] || 0;

        this.lfoGain.connect(osc.detune);
        osc.connect(filter);
        filter.connect(gain);
        subOsc.connect(subGain);
        subGain.connect(gain);
        gain.connect(panner);
        panner.connect(this.bus.chord);

        osc.start();
        subOsc.start();

        this.voices.push({
            osc,
            subOsc,
            filter,
            gain,
            subGain,
            panner,
            detuneBase: (i - 1.5) * 0.7
        });
    }
};

AudioEngine.updateCharacter = function(amount) {
    if(!this.ctx) return;
    const k = amount * 0.5; 
    const samples = 44100;
    const curve = new Float32Array(samples);
    const deg = Math.PI / 180;
    for (let i = 0; i < samples; ++i) {
        let x = (i * 2) / samples - 1;
        curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x)); 
    }
    this.shaper.curve = curve;
};

AudioEngine.resetVoicing = function() {
    this.previousVoicing = null;
};

AudioEngine.midiToFreq = function(midi) {
    return 440 * Math.pow(2, (midi - 69) / 12);
};

AudioEngine.createNoiseBuffer = function(seconds, amount) {
    const size = Math.floor(this.ctx.sampleRate * seconds);
    const buffer = this.ctx.createBuffer(1, size, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < size; i++) data[i] = (Math.random() * 2 - 1) * amount;
    return buffer;
};

AudioEngine.getChordPitchClasses = function(rootIndex, type) {
    const intervals = CHORDS_MAP[type] || CHORDS_MAP.maj;
    const pcs = intervals.map(interval => (rootIndex + interval + 120) % 12);
    if (pcs.length === 3) return [pcs[0], pcs[1], pcs[2], pcs[1]];
    if (pcs.length > this.voiceCount) return pcs.slice(0, this.voiceCount);
    if (pcs.length === this.voiceCount) return pcs;
    while (pcs.length < this.voiceCount) pcs.push(pcs[0]);
    return pcs;
};

AudioEngine.getMidiCandidatesForPitchClass = function(pc, minMidi, maxMidi, refMidi) {
    const out = [];
    for (let oct = 0; oct <= 8; oct++) {
        const note = (oct * 12) + pc;
        if (note >= minMidi && note <= maxMidi) out.push(note);
    }
    out.sort((a, b) => Math.abs(a - refMidi) - Math.abs(b - refMidi));
    return out;
};

AudioEngine.uniquePermutations = function(values) {
    const result = [];
    const used = new Array(values.length).fill(false);
    const sorted = values.slice().sort((a, b) => a - b);
    const walk = (path) => {
        if (path.length === sorted.length) {
            result.push(path.slice());
            return;
        }
        for (let i = 0; i < sorted.length; i++) {
            if (used[i]) continue;
            if (i > 0 && sorted[i] === sorted[i - 1] && !used[i - 1]) continue;
            used[i] = true;
            path.push(sorted[i]);
            walk(path);
            path.pop();
            used[i] = false;
        }
    };
    walk([]);
    return result;
};

AudioEngine.scoreVoicing = function(voicing, refs, centerMidi, chordPitchClasses) {
    let cost = 0;
    for (let i = 0; i < voicing.length; i++) {
        const move = Math.abs(voicing[i] - refs[i]);
        cost += move * move;
        if (move > 4) cost += (move - 4) * 22;
        if (move === 0 && chordPitchClasses.includes(refs[i] % 12)) cost -= 24;
        if (i > 0) {
            const spacing = voicing[i] - voicing[i - 1];
            if (spacing < 3) cost += 90;
            if (spacing > 9) cost += (spacing - 9) * 10;
        }
    }
    const avg = voicing.reduce((sum, n) => sum + n, 0) / voicing.length;
    cost += Math.abs(avg - centerMidi) * 1.1;
    return cost;
};

AudioEngine.chooseBestVoicing = function(pitchClasses) {
    const centerMidi = 58;
    const minMidi = 46;
    const maxMidi = 70;
    const refs = this.previousVoicing && this.previousVoicing.length === this.voiceCount
        ? this.previousVoicing.slice()
        : [50, 53, 57, 60];

    let bestVoicing = null;
    let bestCost = Infinity;
    const permutations = this.uniquePermutations(pitchClasses);

    permutations.forEach(perm => {
        const choices = perm.map((pc, idx) => this.getMidiCandidatesForPitchClass(pc, minMidi, maxMidi, refs[idx]));
        const current = new Array(this.voiceCount);

        const search = (idx, runningCost) => {
            if (runningCost >= bestCost) return;
            if (idx === this.voiceCount) {
                const finalCost = this.scoreVoicing(current, refs, centerMidi, pitchClasses);
                if (finalCost < bestCost) {
                    bestCost = finalCost;
                    bestVoicing = current.slice();
                }
                return;
            }

            for (const note of choices[idx]) {
                if (idx > 0 && note <= current[idx - 1]) continue;
                const localMove = Math.abs(note - refs[idx]);
                let localCost = localMove * localMove;
                if (localMove > 4) localCost += (localMove - 4) * 20;
                if (localMove === 0 && pitchClasses.includes(refs[idx] % 12)) localCost -= 20;
                if (idx > 0) {
                    const spacing = note - current[idx - 1];
                    if (spacing < 3) continue;
                    if (spacing > 9) localCost += (spacing - 9) * 8;
                }
                current[idx] = note;
                search(idx + 1, runningCost + localCost);
            }
        };

        search(0, 0);
    });

    if (!bestVoicing) bestVoicing = refs.slice();
    this.previousVoicing = bestVoicing.slice();
    return bestVoicing.map(midi => this.midiToFreq(midi));
};

AudioEngine.getVoicedFrequencies = function(rootIndex, type) {
    const pitchClasses = this.getChordPitchClasses(rootIndex, type);
    return this.chooseBestVoicing(pitchClasses);
};

AudioEngine.playChord = function(rootIndex, type) {
    if (!this.ctx) return;
    const now = this.ctx.currentTime;
    const preset = CHORD_PRESETS[this.params.chordTone] || CHORD_PRESETS.mellotron;
    const freqs = this.getVoicedFrequencies(rootIndex, type);
    
    // MOBIL OPTIMALIZÁLÁS: Még rövidebb attack és glide
    const attackTime = Math.max(0.02, preset.attack || 0.06);
    const glideTime = 0.03; // Nagyon rövid glide mobil eszközökön
    const targetGain = Math.min(0.16, 0.18 / Math.max(1, freqs.length));

    this.voices.forEach((voice, idx) => {
        const freq = freqs[idx];
        const hasVoice = typeof freq === 'number' && Number.isFinite(freq);

        // Preset alkalmazása
        voice.osc.type = preset.type || 'triangle';
        voice.filter.type = preset.highpass ? 'highpass' : 'lowpass';
        
        // Filter simán változik
        const currentFilterFreq = voice.filter.frequency.value;
        const targetFilterFreq = preset.filter || 2000;
        voice.filter.frequency.cancelScheduledValues(now);
        voice.filter.frequency.setValueAtTime(currentFilterFreq, now);
        voice.filter.frequency.linearRampToValueAtTime(targetFilterFreq, now + 0.05);

        if (hasVoice) {
            const det = ((preset.detune || 0) * 0.18) + voice.detuneBase;
            voice.osc.detune.cancelScheduledValues(now);
            voice.osc.detune.setValueAtTime(det, now);
            
            // KRITIKUS: Frekvencia váltás optimalizálása
            const currentFreq = voice.osc.frequency.value;
            voice.osc.frequency.cancelScheduledValues(now);
            voice.osc.frequency.setValueAtTime(currentFreq, now);
            
            // Ha kis a frekvencia különbség, exponenciális, ha nagy, linear
            const freqDiff = Math.abs(freq - currentFreq);
            if (freqDiff < 100) {
                voice.osc.frequency.exponentialRampToValueAtTime(freq, now + glideTime);
            } else {
                voice.osc.frequency.linearRampToValueAtTime(freq, now + glideTime);
            }

            // Sub oszcillátor
            const currentSubFreq = voice.subOsc.frequency.value;
            voice.subOsc.frequency.cancelScheduledValues(now);
            voice.subOsc.frequency.setValueAtTime(currentSubFreq, now);
            if (freqDiff < 100) {
                voice.subOsc.frequency.exponentialRampToValueAtTime(freq / 2, now + glideTime);
            } else {
                voice.subOsc.frequency.linearRampToValueAtTime(freq / 2, now + glideTime);
            }
            
            voice.subGain.gain.cancelScheduledValues(now);
            voice.subGain.gain.setValueAtTime(voice.subGain.gain.value, now);
            voice.subGain.gain.linearRampToValueAtTime(preset.sub ? 0.14 : 0.0, now + 0.04);
            
            // KRITIKUS: Gain envelope optimalizálása
            const currentGain = voice.gain.gain.value;
            voice.gain.gain.cancelScheduledValues(now);
            voice.gain.gain.setValueAtTime(currentGain < 0.001 ? 0.001 : currentGain, now);
            voice.gain.gain.linearRampToValueAtTime(targetGain, now + attackTime);
        } else {
            voice.gain.gain.cancelScheduledValues(now);
            voice.gain.gain.setValueAtTime(voice.gain.gain.value, now);
            voice.gain.gain.linearRampToValueAtTime(0.0001, now + 0.04);
            
            voice.subGain.gain.cancelScheduledValues(now);
            voice.subGain.gain.setValueAtTime(voice.subGain.gain.value, now);
            voice.subGain.gain.linearRampToValueAtTime(0.0, now + 0.04);
        }
    });
};

AudioEngine.stopAll = function() {
    if (!this.ctx) return;
    const now = this.ctx.currentTime;
    const preset = CHORD_PRESETS[this.params.chordTone] || CHORD_PRESETS.mellotron;
    const releaseTime = Math.min(0.5, preset.release || 0.4);
    
    this.voices.forEach(v => {
        const currentGain = v.gain.gain.value;
        const currentSubGain = v.subGain.gain.value;
        
        v.gain.gain.cancelScheduledValues(now);
        v.gain.gain.setValueAtTime(currentGain < 0.001 ? 0.001 : currentGain, now);
        v.gain.gain.linearRampToValueAtTime(0.0001, now + releaseTime);
        
        v.subGain.gain.cancelScheduledValues(now);
        v.subGain.gain.setValueAtTime(currentSubGain < 0.001 ? 0.001 : currentSubGain, now);
        v.subGain.gain.linearRampToValueAtTime(0.0001, now + releaseTime);
    });
};

AudioEngine.playDrum = function(type) {
    const now = this.ctx.currentTime;
    const vol = 1.0; 
    
    if (type === 1) { // Kick
        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(45, now + 0.15);
        g.gain.setValueAtTime(0.0001, now);
        g.gain.exponentialRampToValueAtTime(vol, now + 0.005);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
        osc.connect(g);
        g.connect(this.bus.drum);
        osc.start(now);
        osc.stop(now + 0.4);
    } else if (type === 2) { // Snare
        const noise = this.ctx.createBufferSource();
        noise.buffer = this.noiseBuffers.snare || this.createNoiseBuffer(0.15, 0.8);
        const f = this.ctx.createBiquadFilter();
        f.type = "bandpass"; f.frequency.value = 2500; f.Q.value = 0.5;
        const g = this.ctx.createGain();
        g.gain.setValueAtTime(vol * 0.9, now);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
        noise.connect(f); f.connect(g); g.connect(this.bus.drum);
        noise.start(now);
    } else if (type >= 3) { // Hat
        const noise = this.ctx.createBufferSource();
        noise.buffer = this.noiseBuffers.hat || this.createNoiseBuffer(0.05, 0.5);
        const f = this.ctx.createBiquadFilter();
        f.type = "highpass"; f.frequency.value = 7000;
        const g = this.ctx.createGain();
        const dur = type===3 ? 0.05 : 0.15;
        g.gain.setValueAtTime(type===3 ? 0.3 : 0.2, now);
        g.gain.exponentialRampToValueAtTime(0.001, now + dur);
        noise.connect(f); f.connect(g); g.connect(this.bus.drum);
        noise.start(now);
    }
};

AudioEngine.toggleRecord = function() {
    if (!this.recorder) {
        this.recorder = new MediaRecorder(this.dest.stream);
        this.chunks = [];
        this.recorder.ondataavailable = (e) => this.chunks.push(e.data);
        this.recorder.onstop = () => {
            const blob = new Blob(this.chunks, { type: 'audio/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'chords-recording.webm';
            a.click();
        };
        this.recorder.start();
        return true;
    } else {
        this.recorder.stop();
        this.recorder = null;
        return false;
    }
};

/* --- APP LOGIC --- */
const app = {
    audio: AudioEngine,
    state: {
        key: 0,
        hold: false,
        drumOn: false,
        bpm: 90,
        currentPattern: 'pop'
    },
    intervalId: null,
    
    // KRITIKUS: Knob értékek perzisztens tárolása
    knobValues: {
        drumVol: 50,
        chordVol: 50,
        bpm: 90,
        fxReverb: 0,
        fxDistortion: 0,
        fxTremolo: 0
    },

    init() {
        this.audio.init();
        this.populateSelectors();
        this.setupKnobs();
        this.renderGrid();
        this.bindEvents();
    },

    populateSelectors() {
        const keySel = document.getElementById('key-select');
        NOTES.forEach((n, i) => {
            const opt = document.createElement('option');
            opt.value = i;
            opt.text = n;
            keySel.appendChild(opt);
        });

        const chordSel = document.getElementById('chord-tone-select');
        for (const [k, v] of Object.entries(CHORD_PRESETS)) {
            const opt = document.createElement('option');
            opt.value = k; opt.text = v.name;
            chordSel.appendChild(opt);
        }

        const patSel = document.getElementById('rhythm-select');
        for (const [k, v] of Object.entries(DRUM_PATTERNS)) {
            const opt = document.createElement('option');
            opt.value = k; opt.text = v.name;
            patSel.appendChild(opt);
        }
    },

    setupKnobs() {
        const knobs = document.querySelectorAll('.knob-container');
        knobs.forEach(knob => {
            const indicator = knob.querySelector('.knob-indicator');
            const min = parseFloat(knob.dataset.min);
            const max = parseFloat(knob.dataset.max);
            let val = parseFloat(knob.dataset.val);
            const param = knob.dataset.param;

            const updateVisuals = (value) => {
                const percent = (value - min) / (max - min);
                const deg = -135 + (percent * 270);
                indicator.style.transform = `translate(-50%, -100%) rotate(${deg}deg)`;
                // KRITIKUS: Mentjük a globális state-be is
                if(this.knobValues.hasOwnProperty(param)) {
                    this.knobValues[param] = value;
                }
            };
            updateVisuals(val);

            // Inicializálás
            if (param === 'drumVol') this.audio.setVol('drum', val);
            if (param === 'chordVol') this.audio.setVol('chord', val);
            if (param === 'bpm') this.state.bpm = Math.round(val);
            if (param === 'fxReverb') this.audio.setEffectAmount('reverb', val);
            if (param === 'fxDistortion') this.audio.setEffectAmount('distortion', val);
            if (param === 'fxTremolo') this.audio.setEffectAmount('tremolo', val);

            let startY = 0, startVal = 0;
            const onMove = (e) => {
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const deltaY = startY - clientY;
                const range = max - min;
                const change = (deltaY / 150) * range; 
                val = Math.max(min, Math.min(max, startVal + change));
                updateVisuals(val);
                
                if(param === 'drumVol') this.audio.setVol('drum', val);
                if(param === 'chordVol') this.audio.setVol('chord', val);
                if(param === 'bpm') {
                    this.state.bpm = Math.round(val);
                    if(this.state.drumOn) this.startDrum();
                }
                if(param === 'fxReverb') this.audio.setEffectAmount('reverb', val);
                if(param === 'fxDistortion') this.audio.setEffectAmount('distortion', val);
                if(param === 'fxTremolo') this.audio.setEffectAmount('tremolo', val);
            };
            
            const onStart = (e) => {
                e.preventDefault();
                startY = e.touches ? e.touches[0].clientY : e.clientY;
                startVal = val;
                window.addEventListener('mousemove', onMove);
                window.addEventListener('mouseup', () => {
                    window.removeEventListener('mousemove', onMove);
                }, {once:true});
                window.addEventListener('touchmove', onMove);
                window.addEventListener('touchend', () => {
                    window.removeEventListener('touchmove', onMove);
                }, {once:true});
            };
            knob.addEventListener('mousedown', onStart);
            knob.addEventListener('touchstart', onStart);
        });
    },

    restoreKnobs() {
        // Visszaállítja a knob vizualizációkat a mentett értékekre
        const knobs = document.querySelectorAll('.knob-container');
        knobs.forEach(knob => {
            const param = knob.dataset.param;
            if(this.knobValues.hasOwnProperty(param)) {
                const value = this.knobValues[param];
                const min = parseFloat(knob.dataset.min);
                const max = parseFloat(knob.dataset.max);
                const percent = (value - min) / (max - min);
                const deg = -135 + (percent * 270);
                const indicator = knob.querySelector('.knob-indicator');
                if(indicator) {
                    indicator.style.transform = `translate(-50%, -100%) rotate(${deg}deg)`;
                }
            }
        });
    },

    renderGrid() {
        const grid = document.getElementById('chord-grid');
        grid.innerHTML = '';
        const root = parseInt(this.state.key);
        
        const majScale = SCALES.major.map(i => (root + i) % 12);
        const relMinRoot = (root + 9) % 12;
        const harmScale = SCALES.harmonicMinor.map(i => (relMinRoot + i) % 12);
        
        const rows = [
            { scale: harmScale, quals: ['mM7', 'm7b5', 'M7', 'm7', '7', 'M7', 'dim7'], css: 'row-harm-7' },
            { scale: harmScale, quals: ['m', 'dim', 'aug', 'm', 'M', 'M', 'dim'], css: 'row-harm-triad' },
            { scale: majScale, quals: ['M7', 'm7', 'm7', 'M7', '7', 'm7', 'm7b5'], css: 'row-major-7' },
            { scale: majScale, quals: ['M', 'm', 'm', 'M', 'M', 'm', 'dim'], css: 'row-major-triad' }
        ];

        rows.forEach((r, rIdx) => {
            r.scale.forEach((nIdx, cIdx) => {
                const noteName = NOTES[nIdx];
                const q = r.quals[cIdx];
                
                let dispQ = q.replace('M', '').replace('dim', '°').replace('aug', '+');
                if(q === 'M7') dispQ = '∆7';
                if(q === 'm7b5') dispQ = 'ø';
                
                const btn = document.createElement('div');
                btn.className = `chord-btn ${r.css}`;
                const roman = (rIdx === 3) ? `<span class="opacity-80 text-[11px] mb-0.5 font-medium" style="color: var(--neon-orange);">${ROMAN_MAJ[cIdx]}</span>` : '';
                btn.innerHTML = `${roman}<span class="font-bold">${noteName}${dispQ}</span>`;
                
                const chordType = CHORD_QUALITY_MAP[q] || 'maj';
                const trigger = (e) => { 
                    e.preventDefault(); 
                    this.triggerChord(btn, nIdx, chordType); 
                };
                btn.onpointerdown = trigger;
                btn.onpointerup = () => { if (!this.state.hold) this.stopChord(btn); };
                btn.onpointerleave = () => { if (!this.state.hold && btn.classList.contains('active')) this.stopChord(btn); };
                
                grid.appendChild(btn);
            });
        });
    },

    triggerChord(btn, root, type) {
        document.querySelectorAll('.chord-btn').forEach(b => b.classList.remove('active', 'hold-active'));
        btn.classList.add('active');
        if(this.state.hold) btn.classList.add('hold-active');
        this.audio.resume();
        this.audio.playChord(root, type);
    },

    stopChord(btn) {
        btn.classList.remove('active');
        this.audio.stopAll();
    },

    startDrum() {
        // EXTRA VÉDELEM: Biztosítsuk hogy a dob hangerő a helyén van
        if(this.audio.bus.drum && this.audio.ctx) {
            const currentDrumGain = this.audio.params.drumVol;
            this.audio.bus.drum.gain.setValueAtTime(currentDrumGain, this.audio.ctx.currentTime);
        }
        
        // Tiszta restart - NEM változtat hangerőn
        if(this.intervalId) {
            clearInterval(this.intervalId);
        }
        let step = 0;
        const intervalTime = (60000 / this.state.bpm) / 4;
        this.intervalId = setInterval(() => {
            const pat = DRUM_PATTERNS[this.state.currentPattern].pat;
            const sound = pat[step % 16];
            if(sound > 0) {
                this.audio.playDrum(sound);
            }
            step++;
        }, intervalTime);
    },

    bindEvents() {
        // --- AUTO FULLSCREEN ON INTERACTION (Fix for hiding clock) ---
        const goFullscreen = () => {
            if (!document.fullscreenElement) {
                try {
                    document.documentElement.requestFullscreen().catch(e => {
                        console.log("Fullscreen request failed (normal if not user gesture):", e);
                    });
                } catch(e) {}
            }
        };
        // Trigger on first touch/click
        document.body.addEventListener('click', goFullscreen, { once: true });
        document.body.addEventListener('touchstart', goFullscreen, { once: true });


        // --- RETRO MODE TOGGLE ---
        const title = document.getElementById('app-title');
        title.addEventListener('click', () => {
            document.body.classList.toggle('theme-lcd');
        });

        // JAVÍTÁS: Haptikus visszajelzés kikapcsolása
        document.addEventListener('contextmenu', (e) => {
            if (e.target.closest('button, .chord-btn, .knob-container')) e.preventDefault();
        });
        
        // JAVÍTÁS: Haptikus visszajelzés tiltása chord gombokon
        document.addEventListener('touchstart', (e) => {
            if (e.target.closest('.chord-btn')) {
                e.preventDefault();
            }
        }, { passive: false });

        document.getElementById('key-select').onchange = (e) => {
            this.state.key = parseInt(e.target.value, 10);
            this.audio.resetVoicing();
            this.renderGrid();
        };

        // JAVÍTÁS: Hangszín váltásnál NEM nullázunk le semmit
        document.getElementById('chord-tone-select').onchange = (e) => {
            this.audio.params.chordTone = e.target.value;
        };

        // JAVÍTÁS: Ritmus váltás menet közben is működik
        document.getElementById('rhythm-select').onchange = (e) => {
            this.state.currentPattern = e.target.value;
            // Ha a dob fut, újraindítjuk az új ritmussal
            if(this.state.drumOn) {
                this.startDrum();
            }
        };

        const playBtn = document.getElementById('drum-btn');
        playBtn.onclick = () => {
            // KRITIKUS: NE VÁLTOZTASS SEMMIT A HANGERŐN!
            // Csak state, UI és interval kezelés
            this.state.drumOn = !this.state.drumOn;
            playBtn.classList.toggle('play-active');
            
            if(this.state.drumOn) {
                // Dob indítás - NEM érinti a bus.drum gain-t
                this.startDrum();
            } else {
                // Dob leállítás - CSAK az interval-t állítjuk le
                if(this.intervalId) {
                    clearInterval(this.intervalId);
                    this.intervalId = null;
                }
            }
            
            // VÉDELEM: Visszaállítjuk a knob vizualizációkat
            setTimeout(() => this.restoreKnobs(), 10);
            // FONTOS: Semmilyen setVol, audio.init, stb. hívás itt!
        };

        const hBtn = document.getElementById('hold-btn');
        hBtn.onclick = () => {
            // KRITIKUS: NE VÁLTOZTASS SEMMIT A HANGERŐN!
            // Csak state és UI kezelés
            this.state.hold = !this.state.hold;
            hBtn.classList.toggle('btn-hold-active');
            
            // Ha kikapcsoljuk a hold-ot, leállítjuk az akkordot
            if(!this.state.hold) {
                this.audio.stopAll();
            }
            
            // VÉDELEM: Visszaállítjuk a knob vizualizációkat
            setTimeout(() => this.restoreKnobs(), 10);
            // FONTOS: Semmilyen setVol, audio.init, stb. hívás itt!
        };

        const rBtn = document.getElementById('rec-btn');
        rBtn.onclick = () => {
            const on = this.audio.toggleRecord();
            if(on) { 
                rBtn.classList.add('btn-rec-active'); 
                rBtn.textContent = 'STOP'; 
            } else { 
                rBtn.classList.remove('btn-rec-active'); 
                rBtn.textContent = 'REC'; 
            }
        };

        document.getElementById('exit-btn').onclick = () => {
            try { window.close(); } catch (err) {}
            try {
                window.open('', '_self');
                window.close();
            } catch (err) {}
            setTimeout(() => {
                if (!document.hidden) window.location.replace('about:blank');
            }, 120);
        };
    }
};

window.onload = () => {
    if (typeof app !== 'undefined') {
        app.init();
    } else {
        console.error('App not defined!');
    }
};
</script>
</body>
</html>