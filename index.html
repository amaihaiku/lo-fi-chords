<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- PWA Settings -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Chords">
    <meta name="theme-color" content="#121214">
    <title>Chords</title>

    <!-- Manifest & Icons (Lyre) -->
    <link rel="manifest" href="manifest.webmanifest">
    <link rel="icon" type="image/svg+xml" href="lyre-icon.svg">
    <link rel="apple-touch-icon" href="lyre-icon.svg">

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@100;200;300;400;500;600&display=swap');

        :root {
            --neon-blue: #00c3ff;
            --neon-purple: #bd00ff;
            --neon-orange: #ff9800;
            --neon-red: #ff3d3d;
            --neon-green: #00ff9d;
            --bg-dark: #121214;
            --panel-bg: rgba(22, 22, 28, 0.95);
            --glass-border: rgba(255, 255, 255, 0.15);
        }

        body {
            font-family: 'Outfit', sans-serif;
            font-weight: 300;
            background-color: var(--bg-dark);
            color: #e0e0e0;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            background-image: radial-gradient(circle at 50% 50%, #1a1a2e 0%, #000000 100%);
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }

        /* Portrait Warning */
        #orientation-overlay { display: none; }
        @media (orientation: portrait) {
            #orientation-overlay { display: flex !important; }
            header, main { display: none !important; }
        }

        /* Phone Rotate Animation */
        @keyframes rotate-phone {
            0%, 20%, 100% { transform: rotate(0deg); }
            50%, 80% { transform: rotate(-90deg); }
        }
        .animate-rotate-phone {
            animation: rotate-phone 2.5s infinite ease-in-out;
            transform-origin: center;
        }

        .glass-panel {
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        /* UI Label - Lighter Gray */
        .ui-label {
            font-family: 'Outfit', sans-serif;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-size: 10px;
            color: #9ca3af;
        }

        /* --- KNOB STYLES --- */
        .knob-container {
            width: 44px;
            height: 44px;
            position: relative;
            cursor: ns-resize;
        }
        .knob-circle {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: linear-gradient(145deg, #2a2a2a, #111);
            border: 1px solid #666;
            position: relative;
            box-shadow: 0 4px 8px rgba(0,0,0,0.6);
        }
        .knob-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 45%;
            background: currentColor;
            transform-origin: bottom center;
            transform: translate(-50%, -100%) rotate(-135deg);
            border-radius: 2px;
            box-shadow: 0 0 5px currentColor;
            pointer-events: none;
        }

        .knob-scale {
            width: 34px;
            display: flex;
            justify-content: space-between;
            font-size: 8px;
            line-height: 1;
            margin-top: 2px;
            color: #6b7280;
            font-family: 'Outfit', sans-serif;
        }
        
        /* Small Knob for Header */
        .knob-sm { width: 34px; height: 34px; }
        .knob-sm .knob-circle { border-width: 1px; }
        .knob-bpm { width: 50px; height: 50px; }
        .knob-scale-bpm { width: 50px; font-size: 9px; }

        .knob-blue { color: var(--neon-blue); }
        .knob-orange { color: var(--neon-orange); }
        .knob-purple { color: var(--neon-purple); }
        .knob-red { color: var(--neon-red); }

        .knob-blue .knob-indicator { background: var(--neon-blue); }
        .knob-orange .knob-indicator { background: var(--neon-orange); }
        .knob-purple .knob-indicator { background: var(--neon-purple); }
        .knob-red .knob-indicator { background: var(--neon-red); }

        .bpm-value {
            font-size: 9px;
            color: #9ca3af;
            margin-top: 1px;
            font-family: 'Outfit', sans-serif;
        }

        /* Chord Buttons */
        .chord-btn {
            transition: all 0.1s ease-out;
            position: relative;
            overflow: hidden;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 300;
            letter-spacing: 0.05em;
        }
        .chord-btn:active { transform: scale(0.98); }
        .chord-btn.active {
            background: #3a3a3a;
            border-color: #555;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
            color: #fff;
            font-weight: 400;
            text-shadow: none;
        }
        .chord-btn.hold-active {
            background: #2a3a2a; 
            border-color: var(--neon-green); 
            border-width: 1px;
        }

        /* Updated Colors per user request */
        .row-major-triad { border-bottom: 2px solid #005f7f; }
        .row-major-7 { border-bottom: 2px solid #ff9800; }
        .row-harm-triad { border-bottom: 2px solid #9c27b0; }
        .row-harm-7 { border-bottom: 2px solid var(--neon-red); } /* CHANGED TO RED */

        select, input {
            background-color: #1a1a1a;
            color: #eee;
            font-family: 'Outfit', sans-serif;
            font-weight: 300;
            letter-spacing: 0.05em;
        }
        
        .play-active { 
            background-color: rgba(0, 255, 157, 0.2) !important;
            border-color: var(--neon-green) !important;
            color: var(--neon-green) !important;
            box-shadow: 0 0 10px rgba(0, 255, 157, 0.3);
        }
        
        .btn-hold-active {
            background-color: var(--neon-green) !important;
            color: #000 !important;
            border-color: var(--neon-green) !important;
            font-weight: 600 !important;
            box-shadow: 0 0 15px rgba(0, 255, 157, 0.4);
        }

        .btn-rec-active { 
            background-color: var(--neon-red) !important; 
            color: white !important;
            border-color: var(--neon-red) !important;
            font-weight: 600 !important;
            box-shadow: 0 0 15px rgba(255, 61, 61, 0.4);
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.8; } 100% { opacity: 1; } }
        
        .custom-scrollbar::-webkit-scrollbar { width: 0px; }

        /* Power Button Style */
        .power-btn:active {
            transform: scale(0.95);
            background-color: rgba(255, 61, 61, 0.2);
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col overflow-hidden text-xs p-2 gap-2 font-light">

    <!-- Orientation Overlay -->
    <div id="orientation-overlay" class="fixed inset-0 z-[100] bg-black flex flex-col items-center justify-center text-center p-6">
        <div class="mb-6 animate-rotate-phone">
            <svg width="80" height="80" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="1.5">
                <rect x="5" y="2" width="14" height="20" rx="2" ry="2" />
                <path d="M12 18h.01" />
            </svg>
        </div>
        <h2 class="text-white text-xl font-light mb-2 tracking-wide font-outfit">Forgatás szükséges</h2>
        <p class="text-gray-400 font-light font-outfit">Az alkalmazás csak fekvő módban használható!</p>
    </div>

    <!-- Header -->
    <header class="glass-panel px-3 py-1 flex items-center justify-between shrink-0 h-24 z-20">
        <!-- Left: Controls -->
        <div class="flex items-center gap-2">
            <h1 class="text-neon-blue font-medium text-xl tracking-[0.1em] font-outfit hidden md:block" style="text-shadow: 0 0 15px rgba(0,195,255,0.3);">CHORDS</h1>
            
            <div class="flex items-center gap-3">
                <div class="flex flex-col">
                    <label class="ui-label mb-0.5">Hangnem</label>
                    <select id="key-select" class="bg-gray-800/50 border border-gray-600 rounded px-1 py-0.5 outline-none text-xs focus:border-neon-blue transition-colors w-16"></select>
                </div>
                <div class="flex flex-col items-center">
                    <label class="ui-label mb-0.5">BPM</label>
                    <div class="knob-container knob-bpm knob-blue" data-param="bpm" data-min="40" data-max="200" data-val="90">
                        <div class="knob-circle"><div class="knob-indicator"></div></div>
                    </div>
                    <div class="knob-scale knob-scale-bpm"><span>40</span><span>200</span></div>
                    <div id="bpm-value" class="bpm-value">90</div>
                </div>
            </div>
        </div>

        <!-- Header Mixer -->
        <div class="flex flex-1 items-center justify-evenly border-l border-gray-700 pl-4 ml-2">
            <!-- DRUM -->
            <div class="flex flex-col items-center">
                <div class="knob-container knob-sm knob-red" data-param="drumVol" data-min="0" data-max="100" data-val="50">
                    <div class="knob-circle"><div class="knob-indicator"></div></div>
                </div>
                <div class="knob-scale"><span>0</span><span>100</span></div>
                <span class="ui-label text-[10px] mt-0 font-bold text-red-400">DOB</span>
            </div>
            <!-- CHORD -->
            <div class="flex flex-col items-center">
                <div class="knob-container knob-sm knob-purple" data-param="chordVol" data-min="0" data-max="100" data-val="50">
                    <div class="knob-circle"><div class="knob-indicator"></div></div>
                </div>
                <div class="knob-scale"><span>0</span><span>100</span></div>
                <span class="ui-label text-[10px] mt-0 font-bold text-purple-400">AKK</span>
            </div>
            <!-- REVERB -->
            <div class="flex flex-col items-center">
                <div class="knob-container knob-sm knob-blue" data-param="fxReverb" data-min="0" data-max="100" data-val="0">
                    <div class="knob-circle"><div class="knob-indicator"></div></div>
                </div>
                <div class="knob-scale"><span>0</span><span>100</span></div>
                <span class="ui-label text-[10px] mt-0 font-bold text-blue-400">REV</span>
            </div>
            <!-- DISTORTION -->
            <div class="flex flex-col items-center">
                <div class="knob-container knob-sm knob-orange" data-param="fxDistortion" data-min="0" data-max="100" data-val="0">
                    <div class="knob-circle"><div class="knob-indicator"></div></div>
                </div>
                <div class="knob-scale"><span>0</span><span>100</span></div>
                <span class="ui-label text-[10px] mt-0 font-bold" style="color: var(--neon-orange);">DST</span>
            </div>
            <!-- TREMOLO -->
            <div class="flex flex-col items-center">
                <div class="knob-container knob-sm knob-purple" data-param="fxTremolo" data-min="0" data-max="100" data-val="0">
                    <div class="knob-circle"><div class="knob-indicator"></div></div>
                </div>
                <div class="knob-scale"><span>0</span><span>100</span></div>
                <span class="ui-label text-[10px] mt-0 font-bold text-purple-400">TRM</span>
            </div>
            <button id="exit-btn" class="power-btn w-8 h-8 rounded-full border border-red-900/50 flex items-center justify-center text-red-500 bg-red-900/10 hover:bg-red-900/30 transition-all shadow-lg" aria-label="Kilépés">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path>
                    <line x1="12" y1="2" x2="12" y2="12"></line>
                </svg>
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 flex gap-2 overflow-hidden min-h-0">
        
        <!-- Left: Chord Matrix -->
        <div class="flex-grow glass-panel p-2 flex flex-col min-w-0 relative">
            <div id="chord-grid" class="grid grid-cols-7 grid-rows-4 gap-2 h-full w-full">
                <!-- JS Generated -->
            </div>
        </div>

        <!-- Center: Console (Distributed Vertically) -->
        <div class="w-52 shrink-0 glass-panel p-3 flex flex-col gap-2 overflow-hidden justify-between">
            
            <!-- 1. Chord Tone -->
            <div class="flex flex-col gap-0.5 border-b border-gray-700/50 pb-2">
                <label class="ui-label text-neon-purple">Hangszinek</label>
                <select id="chord-tone-select" class="bg-gray-800/50 border border-gray-600 rounded px-2 py-1 outline-none text-xs text-white w-full">
                    <!-- Populated by JS -->
                </select>
            </div>

            <!-- 2. Rhythm Control -->
            <div class="flex flex-col gap-1.5 bg-gray-900/40 p-2 rounded border border-gray-700/50">
                <div class="flex items-center justify-between">
                    <label class="ui-label text-[10px]">RITMUS</label>
                </div>
                <select id="rhythm-select" class="bg-gray-800 border border-gray-600 text-xs outline-none w-full p-1 rounded">
                    <!-- Populated by JS -->
                </select>
            </div>

            <!-- 3. Transport -->
            <div class="flex gap-2 h-14">
                <button id="drum-btn" class="flex-1 h-full bg-gray-800 rounded ui-label text-[10px] border border-gray-600 text-gray-300 transition-all shadow-md hover:bg-gray-700 tracking-wider">DOB</button>
                <button id="hold-btn" class="flex-1 h-full bg-gray-800 rounded ui-label text-[10px] border border-gray-600 text-gray-300 transition-all shadow-md hover:bg-gray-700 tracking-wider">HOLD</button>
                <button id="rec-btn" class="flex-1 h-full bg-gray-800 rounded ui-label text-[10px] border border-red-900/60 text-red-400 hover:bg-red-900/20 transition-all shadow-md tracking-wider">REC</button>
            </div>
        </div>

    </main>

<script>
/**
 * CHORDS v3.2
 */

/* --- DATA --- */
const NOTES = ["C", "C#", "D", "Eb", "E", "F", "F#", "G", "Ab", "A", "Bb", "H"];
const ROMAN_MAJ = ["I", "ii", "iii", "IV", "V", "vi", "vii°"];

const SCALES = {
    major: [0, 2, 4, 5, 7, 9, 11],
    harmonicMinor: [0, 2, 3, 5, 7, 8, 11]
};

const CHORD_PRESETS = {
    mellotron:   { name: 'Mellotron',    type: 'triangle', filter: 1700, attack: 0.08, detune: 4, sub: true,  release: 0.52 },
    epiano:      { name: 'E-Piano',      type: 'sine',     filter: 2600, attack: 0.02, detune: 2, fm: true,   fmIndex: 8,  release: 0.36 },
    wurlitzer:   { name: 'Wurlitzer',    type: 'square',   filter: 2200, attack: 0.03, detune: 5, fm: true,   fmIndex: 6,  release: 0.34 },
    fluteOrgan:  { name: 'Flute Organ',  type: 'triangle', filter: 3000, attack: 0.06, detune: 1, sub: true,  release: 0.58 },
    jazzOrgan:   { name: 'Jazz Organ',   type: 'square',   filter: 3200, attack: 0.02, detune: 1, sub: true,  release: 0.42 },
    analogPad:   { name: 'Analog Pad',   type: 'sawtooth', filter: 1300, attack: 0.16, detune: 8,             release: 0.7  },
    tapeChoir:   { name: 'Tape Choir',   type: 'triangle', filter: 1500, attack: 0.12, detune: 6,             release: 0.66 },
    softBrass:   { name: 'Soft Brass',   type: 'sawtooth', filter: 2100, attack: 0.06, detune: 4,             release: 0.44 },
    celestaPad:  { name: 'Celesta Pad',  type: 'sine',     filter: 3400, attack: 0.04, detune: 2, fm: true,   fmIndex: 4,  release: 0.48 },
    nylonKeys:   { name: 'Nylon Keys',   type: 'triangle', filter: 2400, attack: 0.03, detune: 3,             release: 0.4  }
};

const DRUM_PATTERNS = {
    'pop':   { name: 'Standard Pop', pat: [1,0,3,0, 2,0,3,0, 1,0,3,0, 2,0,3,0] },
    'rock':  { name: 'Basic Rock',   pat: [1,0,3,0, 2,0,3,1, 0,0,3,0, 2,0,3,0] },
    'lofi1': { name: 'Lo-Fi Chill 1',pat: [1,0,0,0, 2,0,0,1, 0,0,1,0, 2,0,3,2] },
    'lofi2': { name: 'Lo-Fi Chill 2',pat: [1,0,3,0, 0,0,2,0, 0,1,3,0, 2,0,0,0] },
    'lofi3': { name: 'Drunken Beat', pat: [1,0,0,1, 2,0,0,0, 0,0,1,0, 2,0,0,1] }, 
    'boom':  { name: 'Boom Bap',     pat: [1,0,3,1, 2,0,3,0, 0,1,3,0, 2,0,3,0] },
    'disco': { name: 'Disco 4/4',    pat: [1,3,1,3, 2,3,1,3, 1,3,1,3, 2,3,1,3] },
    'funk':  { name: 'Funky Break',  pat: [1,0,0,1, 2,0,1,0, 0,1,0,0, 2,0,4,0] },
    'trap':  { name: 'Trap Basic',   pat: [1,0,0,0, 2,0,0,0, 1,0,1,0, 2,0,0,0] }, 
    'house': { name: 'House',        pat: [1,3,0,3, 2,3,0,3, 1,3,0,3, 2,3,0,3] },
    'waltz': { name: 'Waltz 3/4',    pat: [1,0,3,3, 2,0,3,0, 1,0,3,3, 2,0,3,0] }, 
    'rnb':   { name: '90s R&B',      pat: [1,0,3,0, 2,0,3,1, 0,0,3,0, 2,0,3,4] },
    'jazz':  { name: 'Jazz Swing',   pat: [1,0,3,4, 0,0,3,0, 0,0,3,4, 0,0,3,0] },
    'dub':   { name: 'Dubstep Lite', pat: [1,0,0,0, 0,0,0,0, 2,0,0,0, 0,0,0,0] },
    'tech':  { name: 'Techno',       pat: [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0] },
    'boss':  { name: 'Bossa Nova',   pat: [1,0,0,1, 0,0,2,0, 1,0,0,1, 0,0,2,0] },
    'shuf':  { name: 'Shuffle',      pat: [1,0,0,1, 2,0,0,1, 1,0,0,1, 2,0,0,1] },
    'slow':  { name: 'Slow Jam',     pat: [1,0,0,0, 0,0,0,0, 2,0,0,0, 0,0,1,0] },
    'brk':   { name: 'Breakbeat',    pat: [1,0,0,0, 2,0,0,0, 0,0,1,0, 2,0,1,0] },
    'min':   { name: 'Minimal',      pat: [1,0,0,0, 0,0,0,1, 0,0,0,0, 2,0,0,0] }
};

const CHORDS_MAP = {
    maj: [0, 4, 7], min: [0, 3, 7], dim: [0, 3, 6], aug: [0, 4, 8],
    maj7: [0, 4, 7, 11], min7: [0, 3, 7, 10], dom7: [0, 4, 7, 10],
    minMaj7: [0, 3, 7, 11], dim7: [0, 3, 6, 9], halfDim: [0, 3, 6, 10]
};

const CHORD_QUALITY_MAP = {
    M: 'maj', m: 'min', dim: 'dim', aug: 'aug',
    M7: 'maj7', m7: 'min7', '7': 'dom7',
    mM7: 'minMaj7', dim7: 'dim7', m7b5: 'halfDim'
};

class AudioEngine {
    constructor() {
        this.ctx = null;
        this.master = null;
        this.bus = { chord: null, drum: null };
        this.filter = null;
        this.limiter = null;
        this.lfo = null;
        this.lfoGain = null;
        this.shaper = null;
        this.activeVoices = [];
        this.previousVoicing = null;
        this.noiseBuffers = { snare: null, hat: null };
        this.voiceCount = 4;
        this.fxNodes = {};
        
        this.params = {
            filterFreq: 2000,
            detune: 15,
            masterVol: 0.5,
            chordVol: 0.5,
            drumVol: 0.5,
            chordTone: 'mellotron'
        };

        this.fxState = {
            reverb: 0,
            distortion: 0,
            tremolo: 0
        };
        
        this.dest = null;
        this.recorder = null;
        this.chunks = [];
    }

    init() {
        const AC = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AC({ latencyHint: 'interactive' });
        
        // --- MASTER CHAIN ---
        this.limiter = this.ctx.createDynamicsCompressor();
        this.limiter.threshold.value = -10;
        this.limiter.ratio.value = 12;
        this.limiter.attack.value = 0.003;
        
        this.master = this.ctx.createGain();
        this.master.gain.value = this.params.masterVol;
        
        // --- BUSES ---
        this.bus.chord = this.ctx.createGain();
        this.bus.chord.gain.value = this.params.chordVol;
        this.bus.drum = this.ctx.createGain();
        this.bus.drum.gain.value = this.params.drumVol;

        // --- GLOBAL FX ---
        this.filter = this.ctx.createBiquadFilter();
        this.filter.type = "lowpass";
        this.filter.Q.value = 0.7; 
        this.filter.frequency.value = this.params.filterFreq;
        
        this.shaper = this.ctx.createWaveShaper();
        this.updateCharacter(25); 

        this.lfo = this.ctx.createOscillator();
        this.lfo.frequency.value = 1.5; 
        this.lfoGain = this.ctx.createGain();
        this.lfoGain.gain.value = 0;
        this.lfo.connect(this.lfoGain);
        this.lfo.start();

        // --- CHORD FX CHAIN (chord only, drums bypass) ---
        this.setupChordEffects();

        // ROUTING
        this.bus.chord.connect(this.fxNodes.distortionInput);
        this.bus.drum.connect(this.master);

        this.filter.connect(this.shaper);
        this.shaper.connect(this.master);
        this.master.connect(this.limiter);
        this.limiter.connect(this.ctx.destination);
        
        this.dest = this.ctx.createMediaStreamDestination();
        this.limiter.connect(this.dest);

        this.noiseBuffers.snare = this.createNoiseBuffer(0.15, 0.8);
        this.noiseBuffers.hat = this.createNoiseBuffer(0.05, 0.5);
    }

    resume() { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); }

    setVol(type, val) {
        if(!this.ctx) return;
        const gain = val / 100;
        if(type === 'chord') this.bus.chord.gain.setTargetAtTime(gain, this.ctx.currentTime, 0.05);
        if(type === 'drum') this.bus.drum.gain.setTargetAtTime(gain, this.ctx.currentTime, 0.05);
    }

    setupChordEffects() {
        const n = this.fxNodes;

        n.distortionInput = this.ctx.createGain();
        n.distortionDry = this.ctx.createGain();
        n.distortionWet = this.ctx.createGain();
        n.distortionSum = this.ctx.createGain();
        n.distortionDrive = this.ctx.createGain();
        n.distortion = this.ctx.createWaveShaper();
        n.distortion.oversample = '4x';

        n.tremoloGain = this.ctx.createGain();
        n.tremoloDepth = this.ctx.createGain();
        n.tremoloLfo = this.ctx.createOscillator();
        n.tremoloLfo.connect(n.tremoloDepth);
        n.tremoloDepth.connect(n.tremoloGain.gain);
        n.tremoloLfo.start();

        n.reverbConvolver = this.ctx.createConvolver();
        n.reverbConvolver.buffer = this.createReverbImpulse(2.8, 2.6);
        n.reverbDry = this.ctx.createGain();
        n.reverbWet = this.ctx.createGain();

        n.distortionInput.connect(n.distortionDry);
        n.distortionDry.connect(n.distortionSum);

        n.distortionInput.connect(n.distortionDrive);
        n.distortionDrive.connect(n.distortion);
        n.distortion.connect(n.distortionWet);
        n.distortionWet.connect(n.distortionSum);

        n.distortionSum.connect(n.tremoloGain);

        n.tremoloGain.connect(n.reverbDry);
        n.reverbDry.connect(this.filter);

        n.tremoloGain.connect(n.reverbConvolver);
        n.reverbConvolver.connect(n.reverbWet);
        n.reverbWet.connect(this.filter);

        this.updateDistortion();
        this.updateTremolo();
        this.updateReverb();
    }

    setEffectAmount(name, amount) {
        if (typeof this.fxState[name] === 'undefined') return;
        this.fxState[name] = Math.max(0, Math.min(100, amount));
        this.updateEffect(name);
    }

    updateEffect(name) {
        if (!this.ctx) return;
        if (name === 'distortion') this.updateDistortion();
        if (name === 'tremolo') this.updateTremolo();
        if (name === 'reverb') this.updateReverb();
    }

    updateDistortion() {
        const n = this.fxNodes;
        if (!n.distortion || !n.distortionDrive) return;
        const amount = this.fxState.distortion;
        const drive = 1 + (amount / 100) * 4.5;
        const wet = (amount / 100) * 0.85;
        n.distortionDrive.gain.setTargetAtTime(drive, this.ctx.currentTime, 0.05);
        n.distortion.curve = amount > 0 ? this.createSoftClipCurve(amount) : this.createIdentityCurve();
        n.distortionWet.gain.setTargetAtTime(wet, this.ctx.currentTime, 0.05);
        n.distortionDry.gain.setTargetAtTime(1 - (wet * 0.65), this.ctx.currentTime, 0.05);
    }

    updateTremolo() {
        const n = this.fxNodes;
        if (!n.tremoloGain) return;
        const amount = this.fxState.tremolo;
        const depth = (amount / 100) * 0.7;
        n.tremoloGain.gain.setTargetAtTime(1 - (depth * 0.5), this.ctx.currentTime, 0.05);
        n.tremoloDepth.gain.setTargetAtTime(depth, this.ctx.currentTime, 0.05);
        n.tremoloLfo.frequency.setTargetAtTime(2 + (amount * 0.06), this.ctx.currentTime, 0.1);
    }

    updateReverb() {
        const n = this.fxNodes;
        if (!n.reverbDry) return;
        const wet = (this.fxState.reverb / 100) * 0.8;
        n.reverbWet.gain.setTargetAtTime(wet, this.ctx.currentTime, 0.06);
        n.reverbDry.gain.setTargetAtTime(1 - (wet * 0.45), this.ctx.currentTime, 0.06);
    }

    createSoftClipCurve(amount) {
        const samples = 2048;
        const curve = new Float32Array(samples);
        const k = 1 + (amount / 100) * 8;
        for (let i = 0; i < samples; i++) {
            const x = ((i * 2) / samples) - 1;
            curve[i] = Math.tanh(k * x) / Math.tanh(k);
        }
        return curve;
    }

    createIdentityCurve() {
        const samples = 512;
        const curve = new Float32Array(samples);
        for (let i = 0; i < samples; i++) curve[i] = ((i * 2) / (samples - 1)) - 1;
        return curve;
    }

    createReverbImpulse(seconds, decay) {
        const length = Math.floor(this.ctx.sampleRate * seconds);
        const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
        for (let ch = 0; ch < 2; ch++) {
            const data = impulse.getChannelData(ch);
            for (let i = 0; i < length; i++) {
                const t = i / length;
                const env = Math.pow(1 - t, decay);
                data[i] = ((Math.random() * 2) - 1) * env;
            }
        }
        return impulse;
    }

    updateCharacter(amount) {
        if(!this.ctx) return;
        const k = amount * 0.5; 
        const samples = 44100;
        const curve = new Float32Array(samples);
        const deg = Math.PI / 180;
        for (let i = 0; i < samples; ++i) {
            let x = (i * 2) / samples - 1;
            curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x)); 
        }
        this.shaper.curve = curve;
    }

    resetVoicing() {
        this.previousVoicing = null;
    }

    midiToFreq(midi) {
        return 440 * Math.pow(2, (midi - 69) / 12);
    }

    createNoiseBuffer(seconds, amount) {
        const size = Math.floor(this.ctx.sampleRate * seconds);
        const buffer = this.ctx.createBuffer(1, size, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < size; i++) data[i] = (Math.random() * 2 - 1) * amount;
        return buffer;
    }

    getChordPitchClasses(rootIndex, type) {
        const intervals = CHORDS_MAP[type] || CHORDS_MAP.maj;
        const pcs = intervals.map(interval => (rootIndex + interval + 120) % 12);
        if (pcs.length === 3) return [pcs[0], pcs[1], pcs[2], pcs[1]];
        if (pcs.length > this.voiceCount) return pcs.slice(0, this.voiceCount);
        if (pcs.length === this.voiceCount) return pcs;
        while (pcs.length < this.voiceCount) pcs.push(pcs[0]);
        return pcs;
    }

    getMidiCandidatesForPitchClass(pc, minMidi, maxMidi, refMidi) {
        const out = [];
        for (let oct = 0; oct <= 8; oct++) {
            const note = (oct * 12) + pc;
            if (note >= minMidi && note <= maxMidi) out.push(note);
        }
        out.sort((a, b) => Math.abs(a - refMidi) - Math.abs(b - refMidi));
        return out;
    }

    uniquePermutations(values) {
        const result = [];
        const used = new Array(values.length).fill(false);
        const sorted = values.slice().sort((a, b) => a - b);
        const walk = (path) => {
            if (path.length === sorted.length) {
                result.push(path.slice());
                return;
            }
            for (let i = 0; i < sorted.length; i++) {
                if (used[i]) continue;
                if (i > 0 && sorted[i] === sorted[i - 1] && !used[i - 1]) continue;
                used[i] = true;
                path.push(sorted[i]);
                walk(path);
                path.pop();
                used[i] = false;
            }
        };
        walk([]);
        return result;
    }

    scoreVoicing(voicing, refs, centerMidi, chordPitchClasses) {
        let cost = 0;
        for (let i = 0; i < voicing.length; i++) {
            const move = Math.abs(voicing[i] - refs[i]);
            cost += move * move;
            if (move > 4) cost += (move - 4) * 22;
            if (move === 0 && chordPitchClasses.includes(refs[i] % 12)) cost -= 24;
            if (i > 0) {
                const spacing = voicing[i] - voicing[i - 1];
                if (spacing < 3) cost += 90;
                if (spacing > 9) cost += (spacing - 9) * 10;
            }
        }
        const avg = voicing.reduce((sum, n) => sum + n, 0) / voicing.length;
        cost += Math.abs(avg - centerMidi) * 1.1;
        return cost;
    }

    chooseBestVoicing(pitchClasses) {
        const centerMidi = 58;
        const minMidi = 46;
        const maxMidi = 70;
        const refs = this.previousVoicing && this.previousVoicing.length === this.voiceCount
            ? this.previousVoicing.slice()
            : [50, 53, 57, 60];

        let bestVoicing = null;
        let bestCost = Infinity;
        const permutations = this.uniquePermutations(pitchClasses);

        permutations.forEach(perm => {
            const choices = perm.map((pc, idx) => this.getMidiCandidatesForPitchClass(pc, minMidi, maxMidi, refs[idx]));
            const current = new Array(this.voiceCount);

            const search = (idx, runningCost) => {
                if (runningCost >= bestCost) return;
                if (idx === this.voiceCount) {
                    const finalCost = this.scoreVoicing(current, refs, centerMidi, pitchClasses);
                    if (finalCost < bestCost) {
                        bestCost = finalCost;
                        bestVoicing = current.slice();
                    }
                    return;
                }

                for (const note of choices[idx]) {
                    if (idx > 0 && note <= current[idx - 1]) continue;
                    const localMove = Math.abs(note - refs[idx]);
                    let localCost = localMove * localMove;
                    if (localMove > 4) localCost += (localMove - 4) * 20;
                    if (localMove === 0 && pitchClasses.includes(refs[idx] % 12)) localCost -= 20;
                    if (idx > 0) {
                        const spacing = note - current[idx - 1];
                        if (spacing < 3) continue;
                        if (spacing > 9) localCost += (spacing - 9) * 8;
                    }
                    current[idx] = note;
                    search(idx + 1, runningCost + localCost);
                }
            };

            search(0, 0);
        });

        if (!bestVoicing) bestVoicing = refs.slice();
        this.previousVoicing = bestVoicing.slice();
        return bestVoicing.map(midi => this.midiToFreq(midi));
    }

    getVoicedFrequencies(rootIndex, type) {
        const pitchClasses = this.getChordPitchClasses(rootIndex, type);
        return this.chooseBestVoicing(pitchClasses);
    }

    playChord(rootIndex, type) {
        if (!this.ctx) return;
        const now = this.ctx.currentTime;
        const preset = CHORD_PRESETS[this.params.chordTone] || CHORD_PRESETS.mellotron;
        const freqs = this.getVoicedFrequencies(rootIndex, type);
        const releaseTime = Math.max(0.14, Math.min(0.95, preset.release || 0.5));
        const attackTime = Math.max(0.01, preset.attack || 0.06);
        const targetGain = Math.min(0.22, 0.24 / Math.max(1, freqs.length));

        this.activeVoices.forEach(v => {
            if(v.state === 'playing') {
                v.state = 'releasing';
                if(v.gains) v.gains.forEach(g => {
                    g.gain.cancelScheduledValues(now);
                    g.gain.setValueAtTime(Math.max(0.0001, g.gain.value), now);
                    g.gain.exponentialRampToValueAtTime(0.0001, now + releaseTime);
                });
                v.osc.forEach(o => o.stop(now + releaseTime + 0.04));
            }
        });
        this.activeVoices = [];

        freqs.forEach((freq) => {
            const oscList = [];
            const gainList = [];
            const osc = this.ctx.createOscillator();
            const vGain = this.ctx.createGain();
            const panner = this.ctx.createStereoPanner();
            
            osc.type = preset.type;
            let detune = (Math.random() - 0.5) * ((preset.detune || 5) * 0.3);
            osc.detune.value = detune;
            osc.frequency.value = freq;
            this.lfoGain.connect(osc.detune);

            if (preset.fm) {
                const mod = this.ctx.createOscillator();
                const modGain = this.ctx.createGain();
                mod.type = 'sine';
                mod.frequency.value = freq * 2.0;
                modGain.gain.value = (preset.fmIndex || 50);
                mod.connect(modGain);
                modGain.connect(osc.frequency);
                mod.start(now);
                oscList.push(mod); 
            }

            let sourceNode = osc;
            if (preset.filter) {
                const localFilter = this.ctx.createBiquadFilter();
                localFilter.type = preset.highpass ? "highpass" : "lowpass";
                localFilter.frequency.value = preset.filter;
                sourceNode.connect(localFilter);
                localFilter.connect(vGain);
            } else {
                sourceNode.connect(vGain);
            }

            if (preset.sub) {
                const subOsc = this.ctx.createOscillator();
                subOsc.type = 'sine';
                subOsc.frequency.value = freq / 2;
                const subGain = this.ctx.createGain();
                subGain.gain.value = 0.22;
                subOsc.connect(subGain);
                subGain.connect(vGain); 
                subOsc.start(now);
                oscList.push(subOsc);
            }

            vGain.connect(panner);
            panner.connect(this.bus.chord);
            panner.pan.value = (Math.random() - 0.5) * 0.22;

            osc.start(now);
            oscList.push(osc);
            gainList.push(vGain);

            vGain.gain.setValueAtTime(0.0001, now);
            vGain.gain.exponentialRampToValueAtTime(targetGain, now + attackTime);
            this.activeVoices.push({ osc: oscList, gains: gainList, state: 'playing' });
        });
    }

    stopAll() {
        const now = this.ctx.currentTime;
        const releaseTime = 0.12;
        this.activeVoices.forEach(v => {
            if(v.gains) {
                v.gains.forEach(g => {
                    g.gain.cancelScheduledValues(now);
                    g.gain.setValueAtTime(Math.max(0.0001, g.gain.value), now);
                    g.gain.exponentialRampToValueAtTime(0.0001, now + releaseTime);
                });
            }
            v.osc.forEach(o => o.stop(now + releaseTime + 0.04));
        });
        this.activeVoices = [];
    }

    playDrum(type) {
        const now = this.ctx.currentTime;
        const vol = 1.0; 
        
        if (type === 1) { // Kick
            const osc = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.exponentialRampToValueAtTime(45, now + 0.15);
            g.gain.setValueAtTime(0.0001, now);
            g.gain.exponentialRampToValueAtTime(vol, now + 0.005);
            g.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
            osc.connect(g);
            g.connect(this.bus.drum);
            osc.start(now);
            osc.stop(now + 0.4);
        } else if (type === 2) { // Snare
            const noise = this.ctx.createBufferSource();
            noise.buffer = this.noiseBuffers.snare || this.createNoiseBuffer(0.15, 0.8);
            const f = this.ctx.createBiquadFilter();
            f.type = "bandpass"; f.frequency.value = 2500; f.Q.value = 0.5;
            const g = this.ctx.createGain();
            g.gain.setValueAtTime(vol * 0.9, now);
            g.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
            noise.connect(f); f.connect(g); g.connect(this.bus.drum);
            noise.start(now);
        } else if (type >= 3) { // Hat
            const noise = this.ctx.createBufferSource();
            noise.buffer = this.noiseBuffers.hat || this.createNoiseBuffer(0.05, 0.5);
            const f = this.ctx.createBiquadFilter();
            f.type = "highpass"; f.frequency.value = 7000;
            const g = this.ctx.createGain();
            const dur = type===3 ? 0.05 : 0.15;
            g.gain.setValueAtTime(type===3 ? 0.3 : 0.2, now);
            g.gain.exponentialRampToValueAtTime(0.001, now + dur);
            noise.connect(f); f.connect(g); g.connect(this.bus.drum);
            noise.start(now);
        }
    }

    toggleRecord() {
        if (this.recorder && this.recorder.state === 'recording') {
            this.recorder.stop();
            return false;
        } else {
            this.chunks = [];
            this.recorder = new MediaRecorder(this.dest.stream);
            this.recorder.ondataavailable = e => this.chunks.push(e.data);
            this.recorder.onstop = e => {
                const blob = new Blob(this.chunks, { type: 'audio/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `lofi-chord-session-${Date.now()}.webm`;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => URL.revokeObjectURL(url), 100);
            };
            this.recorder.start();
            return true;
        }
    }
}

const app = {
    audio: new AudioEngine(),
    state: { key: 0, bpm: 90, drumOn: false, hold: false, currentPattern: 'pop' },
    intervalId: null,

    init() {
        this.audio.init();
        this.populateSelects();
        this.renderGrid();
        this.bindEvents();
        this.setupKnobs();
        
        // Ensure AudioContext is inited on first interaction
        const resumeAudio = () => {
            if (this.audio.ctx && this.audio.ctx.state === 'suspended') {
                this.audio.ctx.resume();
            }
            document.removeEventListener('click', resumeAudio);
            document.removeEventListener('touchstart', resumeAudio);
        };
        document.addEventListener('click', resumeAudio);
        document.addEventListener('touchstart', resumeAudio);
    },

    populateSelects() {
        const keySel = document.getElementById('key-select');
        NOTES.forEach((n, i) => {
            const opt = document.createElement('option');
            opt.value = i; opt.text = n;
            keySel.appendChild(opt);
        });

        const chordSel = document.getElementById('chord-tone-select');
        for (const [k, v] of Object.entries(CHORD_PRESETS)) {
            const opt = document.createElement('option');
            opt.value = k; opt.text = v.name;
            chordSel.appendChild(opt);
        }

        const patSel = document.getElementById('rhythm-select');
        for (const [k, v] of Object.entries(DRUM_PATTERNS)) {
            const opt = document.createElement('option');
            opt.value = k; opt.text = v.name;
            patSel.appendChild(opt);
        }
    },

    setupKnobs() {
        const knobs = document.querySelectorAll('.knob-container');
        const bpmValue = document.getElementById('bpm-value');
        knobs.forEach(knob => {
            const indicator = knob.querySelector('.knob-indicator');
            const min = parseFloat(knob.dataset.min);
            const max = parseFloat(knob.dataset.max);
            let val = parseFloat(knob.dataset.val);
            const param = knob.dataset.param;

            const updateVisuals = (value) => {
                const percent = (value - min) / (max - min);
                const deg = -135 + (percent * 270);
                indicator.style.transform = `translate(-50%, -100%) rotate(${deg}deg)`;
            };
            updateVisuals(val);

            if (param === 'drumVol') this.audio.setVol('drum', val);
            if (param === 'chordVol') this.audio.setVol('chord', val);
            if (param === 'bpm') {
                this.state.bpm = Math.round(val);
                if (bpmValue) bpmValue.textContent = `${Math.round(val)}`;
            }
            if (param === 'fxReverb') this.audio.setEffectAmount('reverb', val);
            if (param === 'fxDistortion') this.audio.setEffectAmount('distortion', val);
            if (param === 'fxTremolo') this.audio.setEffectAmount('tremolo', val);

            let startY = 0, startVal = 0;
            const onMove = (e) => {
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const deltaY = startY - clientY;
                const range = max - min;
                const change = (deltaY / 150) * range; 
                val = Math.max(min, Math.min(max, startVal + change));
                updateVisuals(val);
                
                if(param === 'drumVol') this.audio.setVol('drum', val);
                if(param === 'chordVol') this.audio.setVol('chord', val);
                if(param === 'bpm') {
                    this.state.bpm = Math.round(val);
                    if (bpmValue) bpmValue.textContent = `${Math.round(val)}`;
                    if(this.state.drumOn) this.startDrum();
                }
                if(param === 'fxReverb') this.audio.setEffectAmount('reverb', val);
                if(param === 'fxDistortion') this.audio.setEffectAmount('distortion', val);
                if(param === 'fxTremolo') this.audio.setEffectAmount('tremolo', val);
            };
            
            const onStart = (e) => {
                e.preventDefault();
                startY = e.touches ? e.touches[0].clientY : e.clientY;
                startVal = val;
                window.addEventListener('mousemove', onMove);
                window.addEventListener('mouseup', () => {
                    window.removeEventListener('mousemove', onMove);
                }, {once:true});
                window.addEventListener('touchmove', onMove);
                window.addEventListener('touchend', () => {
                    window.removeEventListener('touchmove', onMove);
                }, {once:true});
            };
            knob.addEventListener('mousedown', onStart);
            knob.addEventListener('touchstart', onStart);
        });
    },

    renderGrid() {
        const grid = document.getElementById('chord-grid');
        grid.innerHTML = '';
        const root = parseInt(this.state.key);
        
        const majScale = SCALES.major.map(i => (root + i) % 12);
        const relMinRoot = (root + 9) % 12;
        const harmScale = SCALES.harmonicMinor.map(i => (relMinRoot + i) % 12);
        
        const rows = [
            { scale: harmScale, quals: ['mM7', 'm7b5', 'M7', 'm7', '7', 'M7', 'dim7'], css: 'row-harm-7' },
            { scale: harmScale, quals: ['m', 'dim', 'aug', 'm', 'M', 'M', 'dim'], css: 'row-harm-triad' },
            { scale: majScale, quals: ['M7', 'm7', 'm7', 'M7', '7', 'm7', 'm7b5'], css: 'row-major-7' },
            { scale: majScale, quals: ['M', 'm', 'm', 'M', 'M', 'm', 'dim'], css: 'row-major-triad' }
        ];

        rows.forEach((r, rIdx) => {
            r.scale.forEach((nIdx, cIdx) => {
                const noteName = NOTES[nIdx];
                const q = r.quals[cIdx];
                
                // Modified Notation: "maj7" -> "∆7", "m7b5" -> "ø"
                let dispQ = q.replace('M', '').replace('dim', '°').replace('aug', '+');
                if(q === 'M7') dispQ = '∆7';
                if(q === 'm7b5') dispQ = 'ø';
                
                const btn = document.createElement('div');
                btn.className = `chord-btn ${r.css}`;
                // CHANGED: Roman numerals to neon-orange
                const roman = (rIdx === 3) ? `<span class="opacity-80 text-[11px] mb-0.5 font-medium" style="color: var(--neon-orange);">${ROMAN_MAJ[cIdx]}</span>` : '';
                btn.innerHTML = `${roman}<span class="font-bold">${noteName}${dispQ}</span>`;
                
                const chordType = CHORD_QUALITY_MAP[q] || 'maj';
                const trigger = (e) => { e.preventDefault(); this.triggerChord(btn, nIdx, chordType); };
                btn.onpointerdown = trigger;
                btn.onpointerup = () => { if (!this.state.hold) this.stopChord(btn); };
                btn.onpointerleave = () => { if (!this.state.hold && btn.classList.contains('active')) this.stopChord(btn); };
                
                grid.appendChild(btn);
            });
        });
    },

    triggerChord(btn, root, type) {
        document.querySelectorAll('.chord-btn').forEach(b => b.classList.remove('active', 'hold-active'));
        btn.classList.add('active');
        if(this.state.hold) btn.classList.add('hold-active');
        this.audio.resume();
        this.audio.playChord(root, type);
    },

    stopChord(btn) {
        btn.classList.remove('active');
        this.audio.stopAll();
    },

    startDrum() {
        if(this.intervalId) clearInterval(this.intervalId);
        let step = 0;
        this.intervalId = setInterval(() => {
            const pat = DRUM_PATTERNS[this.state.currentPattern].pat;
            const sound = pat[step % 16];
            if(sound > 0) this.audio.playDrum(sound);
            step++;
        }, (60000 / this.state.bpm) / 4);
    },

    bindEvents() {
        document.getElementById('key-select').onchange = (e) => {
            this.state.key = parseInt(e.target.value, 10);
            this.audio.resetVoicing();
            this.renderGrid();
        };

        document.getElementById('chord-tone-select').onchange = (e) => this.audio.params.chordTone = e.target.value;
        document.getElementById('rhythm-select').onchange = (e) => this.state.currentPattern = e.target.value;

        const playBtn = document.getElementById('drum-btn');
        playBtn.onclick = () => {
            this.state.drumOn = !this.state.drumOn;
            playBtn.classList.toggle('play-active');
            if(this.state.drumOn) this.startDrum(); else clearInterval(this.intervalId);
        };

        const hBtn = document.getElementById('hold-btn');
        hBtn.onclick = () => {
            this.state.hold = !this.state.hold;
            hBtn.classList.toggle('btn-hold-active');
            if(!this.state.hold) this.audio.stopAll();
        };

        const rBtn = document.getElementById('rec-btn');
        rBtn.onclick = () => {
            const on = this.audio.toggleRecord();
            if(on) { 
                rBtn.classList.add('btn-rec-active'); 
                rBtn.textContent = 'STOP'; 
            } else { 
                rBtn.classList.remove('btn-rec-active'); 
                rBtn.textContent = 'REC'; 
            }
        };

        document.getElementById('exit-btn').onclick = () => {
            try { window.close(); } catch (err) {}
            try {
                window.open('', '_self');
                window.close();
            } catch (err) {}
            setTimeout(() => {
                if (!document.hidden) window.location.replace('about:blank');
            }, 120);
        };
    }
};

window.onload = () => {
    if (typeof app !== 'undefined') {
        app.init();
    } else {
        console.error('App not defined!');
    }
};
</script>
</body>
</html>
